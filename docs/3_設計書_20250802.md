# 法令検索・法改正支援アプリケーション 設計書

**作成日**: 2025 年 8 月 2 日  
**バージョン**: 1.0  
**プロジェクト名**: LawFinder

## 1. はじめに

### 1.1 目的

本設計書は、日本政府が公開する法令標準 XML データを活用し、法令間の参照関係を自動抽出・管理することで、法改正時の影響分析を効率化するシステムの設計を定義するものである。

本システムは 2 つのフェーズに分けて構築する：

- **Phase 1**: 法令間の関係性を可視化する静的サイト（一般公開用）
- **Phase 2**: 役所向けの法令改正支援システム（ハネ改正検出等）

### 1.2 スコープ

#### Phase 1（静的法令閲覧サイト）

- 政府標準法令 XML の解析と構造化
- 法令間参照関係の自動リンク生成
- 静的 HTML ファイルの生成
- クライアントサイド検索機能

#### Phase 2（法令改正支援システム）

- 改正影響（ハネ改正）の検出と分析
- AI 支援による参照関係の精査
- 読替・準用支援機能
- ユーザー管理と権限制御

### 1.3 前提条件

- 法令データは政府が公開する標準 XML 形式に準拠
- 初期データとして約 10,000 件の法令 XML ファイルが存在
- OpenAI GPT-4o API へのアクセスが可能

## 2. システム要件

### 2.1 機能要件

#### 2.1.1 法令データ管理

- **FR-001**: 政府標準 XML 形式の法令データを解析し、構造化して保存する
- **FR-002**: 法令、条、項、号の階層構造を維持して管理する
- **FR-003**: 法令のメタデータ（公布日、施行日、改正履歴）を管理する

#### 2.1.2 参照関係抽出

- **FR-004**: 条文から他法令への参照を自動抽出する
- **FR-005**: 準用、みなし、読み替え等の参照種別を識別する
- **FR-006**: 抽出した参照関係に信頼度スコアを付与する

#### 2.1.3 AI 支援機能

- **FR-007**: GPT-4o を使用して参照関係の妥当性を検証する
- **FR-008**: 曖昧な参照や誤った参照を検出し、修正候補を提示する
- **FR-009**: 文脈を考慮した意味的な参照解析を行う

#### 2.1.4 改正影響分析

- **FR-010**: 改正対象条文から影響を受ける法令・条文を特定する
- **FR-011**: 多段階の間接参照も含めて影響範囲を分析する
- **FR-012**: 影響分析結果を視覚的に表示する

#### 2.1.5 検索機能

- **FR-013**: キーワードによる全文検索を提供する
- **FR-014**: 法令名、条番号による絞り込み検索を提供する
- **FR-015**: 参照関係を考慮した関連条文検索を提供する

### 2.2 非機能要件

#### 2.2.1 性能要件

- **NFR-001**: 法令一覧の表示は 1 秒以内に完了する
- **NFR-002**: 改正影響分析（深度 3）は 5 秒以内に完了する
- **NFR-003**: 100 人の同時アクセスに対応する

#### 2.2.2 可用性要件

- **NFR-004**: システム稼働率 99.5%以上を維持する
- **NFR-005**: 計画停止を除き、24 時間 365 日利用可能とする

#### 2.2.3 セキュリティ要件

- **NFR-006**: 通信は HTTPS で暗号化する
- **NFR-007**: ユーザー認証と権限管理を実装する
- **NFR-008**: 操作ログを記録し、監査可能とする

## 3. システムアーキテクチャ

### 3.1 全体構成

#### Phase 1: 静的サイトアーキテクチャ

```
┌─────────────────────────────────────────────────────────────┐
│                    利用者（Webブラウザ）                       │
└─────────────────────────────────────┬───────────────────────┘
                                      │HTTPS
┌─────────────────────────────────────┴───────────────────────┐
│                        CDN / 静的ホスティング                  │
│               (GitHub Pages / Netlify / Vercel)              │
└─────────────────────────────────────┬───────────────────────┘
                                      │
┌─────────────────────────────────────┴───────────────────────┐
│                       静的ファイル群                          │
│  ┌─────────────┬─────────────┬─────────────┬─────────────┐ │
│  │ HTML Files  │ JavaScript  │ CSS Files   │ Search Index│ │
│  │ (各法令)    │ (検索機能)   │ (スタイル)   │ (JSON)      │ │
│  └─────────────┴─────────────┴─────────────┴─────────────┘ │
└─────────────────────────────────────────────────────────────┘

【ビルドプロセス】
┌─────────────────────────────────────────────────────────────┐
│                    ビルド時処理（Node.js）                     │
│  ┌─────────────┬─────────────┬─────────────┬─────────────┐ │
│  │ XMLパーサー  │ リンク抽出   │ HTML生成    │ Index生成   │ │
│  └─────────────┴─────────────┴─────────────┴─────────────┘ │
└─────────────────────────────────────┬───────────────────────┘
                                      │
┌─────────────────────────────────────┴───────────────────────┐
│                      法令XMLデータ                            │
└─────────────────────────────────────────────────────────────┘
```

#### Phase 2: フルスタックアーキテクチャ

```
┌─────────────────────────────────────────────────────────────┐
│                       管理者（Webブラウザ）                     │
└─────────────────────────────────────┬───────────────────────┘
                                      │HTTPS
┌─────────────────────────────────────┴───────────────────────┐
│                    フロントエンド層                            │
│                 - React/Next.js (管理画面)                    │
│                 - 可視化ライブラリ（D3.js）                     │
└─────────────────────────────────────┬───────────────────────┘
                                      │REST API / GraphQL
┌─────────────────────────────────────┴───────────────────────┐
│                    アプリケーション層                          │
│  ┌─────────────┬─────────────┬─────────────┬─────────────┐ │
│  │ APIサーバー  │ 参照抽出    │ 影響分析    │ AI連携      │ │
│  │ (Express.js)│ エンジン    │ エンジン    │ モジュール  │ │
│  └─────────────┴─────────────┴─────────────┴─────────────┘ │
└─────────────────────────────────────┬───────────────────────┘
                                      │
┌─────────────────────────────────────┴───────────────────────┐
│                    データ層                                   │
│  ┌─────────────┬─────────────┬─────────────┬─────────────┐ │
│  │ Neo4j      │Elasticsearch│ PostgreSQL │ Redis       │ │
│  │(グラフDB)   │(全文検索)    │(メタデータ) │(キャッシュ)  │ │
│  └─────────────┴─────────────┴─────────────┴─────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 コンポーネント設計

#### 3.2.1 フロントエンド

- **技術スタック**: React 18.x, Next.js 14.x
- **UI ライブラリ**: Material-UI v5
- **状態管理**: Redux Toolkit
- **グラフ可視化**: D3.js, Cytoscape.js

#### 3.2.2 バックエンド

- **API フレームワーク**: Express.js 4.x
- **ランタイム**: Node.js 18.x LTS
- **非同期処理**: Bull Queue + Redis
- **認証**: JWT (jsonwebtoken)
- **バリデーション**: Joi / express-validator
- **ORM**: Prisma (PostgreSQL) / Mongoose (MongoDB)
- **ロギング**: Winston

#### 3.2.3 データストア

- **グラフ DB**: Neo4j 5.x（参照関係管理）
- **全文検索**: Elasticsearch 8.x
- **RDB**: PostgreSQL 15.x（メタデータ）
- **キャッシュ**: Redis 7.x

#### 3.2.4 AI/LLM 連携

##### Phase 1: ローカル LLM

- **モデル**: Llama-3-ELYZA-JP-8B
- **実行環境**: Ollama / llama.cpp
- **用途**: 基本的な参照解決、曖昧性の解消
- **メリット**:
  - コスト削減（API 料金不要）
  - レスポンス速度向上
  - データのプライバシー確保

##### Phase 2: 商用 LLM 併用

- **プライマリ**: Llama-3-ELYZA-JP-8B（基本処理）
- **セカンダリ**: OpenAI GPT-4o API（高度な解析）
- **LLM フレームワーク**: LangChain
- **使い分け**:
  - 簡単な参照解決: ローカル LLM
  - 複雑な読み替え規定: GPT-4o
  - 信頼度が低い場合: GPT-4o で再検証

## 4. データ設計

### 4.1 データモデル

#### 4.1.1 法令エンティティ

```sql
-- 法令マスタ
CREATE TABLE laws (
    law_id VARCHAR(20) PRIMARY KEY,      -- 例: 320AC0000000046
    law_type VARCHAR(20) NOT NULL,       -- Act, CabinetOrder等
    law_num VARCHAR(100) NOT NULL,       -- 法令番号
    law_title VARCHAR(500) NOT NULL,     -- 法令名
    law_title_kana VARCHAR(500),         -- 法令名かな
    era VARCHAR(20) NOT NULL,            -- 元号
    year INTEGER NOT NULL,               -- 年
    num INTEGER NOT NULL,                -- 号
    promulgate_date DATE NOT NULL,       -- 公布日
    enforce_date DATE,                   -- 施行日
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 条文
CREATE TABLE articles (
    article_id VARCHAR(50) PRIMARY KEY,   -- 例: 320AC0000000046_art1
    law_id VARCHAR(20) NOT NULL,
    article_num INTEGER NOT NULL,         -- 条番号
    article_title VARCHAR(200),           -- 条見出し
    content TEXT NOT NULL,                -- 条文内容
    created_at TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (law_id) REFERENCES laws(law_id)
);

-- 項
CREATE TABLE paragraphs (
    paragraph_id VARCHAR(60) PRIMARY KEY,
    article_id VARCHAR(50) NOT NULL,
    paragraph_num INTEGER NOT NULL,
    content TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (article_id) REFERENCES articles(article_id)
);
```

#### 4.1.2 グラフデータモデル（Neo4j）

##### グラフ DB 採用の設計根拠

法令間の参照関係は本質的にグラフ構造であり、以下の理由から Neo4j を採用：

**メリット**

1. **自然なデータモデリング**: 法令間の複雑な参照関係をノードとエッジで直感的に表現
2. **高速なグラフ探索**: ハネ改正の影響分析で多段階の参照を効率的に探索可能
3. **柔軟なスキーマ**: 新しい参照タイプや属性の追加が容易
4. **グラフアルゴリズムの活用**: 中心性分析、最短経路、コミュニティ検出など

**デメリットと対策**

1. **学習コスト**: Cypher クエリ言語の習得が必要 → ドキュメント整備と ORM 活用
2. **集計処理**: 統計処理は RDBMS が優位 → PostgreSQL との併用
3. **運用コスト**: 商用ライセンス費用 → Community Edition から開始

##### 柔軟なグラフ構造設計

```cypher
// ノード定義
(:Law {
    law_id: String,
    law_title: String,
    law_type: String,
    promulgate_date: Date
})

(:Article {
    article_id: String,
    article_num: Integer,
    content: String
})

(:Paragraph {
    paragraph_id: String,
    paragraph_num: Integer,
    content: String
})

// 汎用的な参照リレーション
// 固定的なリレーションタイプではなく、プロパティで詳細を管理
(:Article)-[:REFERENCES {
    // 基本情報
    reference_id: String,
    source_text: String,           // 元の参照テキスト

    // パターン分類
    primary_type: String,          // 主要タイプ（下記参照）
    secondary_types: [String],     // 副次的な特徴

    // 主要タイプの種類：
    // - APPLY: 準用（準用する、について準用）
    // - DEEM: みなす（とみなす、看做す）
    // - REPLACE: 読み替え（読み替える、と読み替えるものとする）
    // - EXCEPT: 除外（除く、を除き、場合を除き）
    // - FOLLOW: 従う・基づく（に従い、基づき、による）
    // - LIMIT: 限定（この限りでない、に限り、場合に限る）
    // - REGARDLESS: 無関係（にかかわらず、を問わず）
    // - RELATE: 関係（に関して、について、関する限り）
    // - STIPULATE: 規定（定める、規定により、別段の定め）
    // - EXAMPLE: 例示（例による、の例により）
    // - SIMILAR: 同様（同様とする、も同様とする）
    // - SUBSTITUTE: 代替（代えて、に代わって）
    // - ADDITION: 追加（ほか、のほか）

    // 詳細情報
    conditions: [String],          // 適用条件（「ただし」等の条件文）
    exceptions: [String],          // 例外事項
    target_specification: {        // 参照先の詳細仕様
        level: String,             // law, article, paragraph, item
        position: String,          // 前項、次条、同項等の位置参照
        enumeration: [String]      // 各号、次に掲げる等の列挙
    },

    // AI解析結果
    ai_analysis: {
        confidence: Float,
        target_resolved: Boolean,
        ambiguity_notes: String,
        verified_at: DateTime
    },

    // メタデータ
    extracted_at: DateTime,
    extraction_method: String,
    human_verified: Boolean
}]->(:Article)

// 構造的リレーション
(:Law)-[:HAS_ARTICLE]->(:Article)
(:Article)-[:HAS_PARAGRAPH]->(:Paragraph)
```

この設計により：

- 新しい参照パターンをプロパティとして柔軟に追加可能
- AI による解析結果と人間の検証結果を併存
- 将来の拡張性を確保しつつ、基本的なクエリ性能を維持

### 4.2 参照関係データ構造

```json
{
  "reference_id": "ref_001",
  "source": {
    "law_id": "320AC0000000046",
    "article_id": "320AC0000000046_art2",
    "paragraph_id": "320AC0000000046_art2_para1",
    "text": "旧法第三条及昭和二十年法律第九号附則第三項ノ規定ハ..."
  },
  "target": {
    "law_id": "145AC0000000009",
    "article_id": "145AC0000000009_art3",
    "paragraph_id": null
  },
  "reference_type": "準用",
  "confidence_score": 0.95,
  "ai_verification": {
    "verified": true,
    "verified_at": "2025-08-02T10:00:00Z",
    "reasoning": "参照先の法令名と条番号が明確に特定されており..."
  }
}
```

## 5. 処理設計

### 5.1 参照関係抽出フロー

```
XMLファイル → XMLパーサー → 条文テキスト抽出 → パターンマッチング
    ↓                                              ↓
グラフDB登録 ← AI検証 ← 参照先の存在確認 ← 参照先正規化
```

### 5.2 パターンマッチング仕様

#### 5.2.1 参照パターンの種類

実際の法令 XML データの調査から、以下の多様な参照パターンが確認されている：

##### 主要な参照パターン

```
1. 準用: "準用する", "準用し", "について準用する"
2. みなす: "みなす", "とみなす", "とみなして", "看做す"（旧字体）
3. 読み替え: "読み替える", "読み替えて", "と読み替えるものとする"
4. 適用: "適用する", "適用しない", "について適用する"
5. 例による: "例による", "例により", "の例による"
6. 従う: "従う", "従い", "に従って", "に従い"
7. 基づく: "基づく", "基づき", "に基づいて"
8. よる: "による", "により", "によって"
9. 除く: "除く", "を除き", "を除いて", "場合を除き"
10. 代える: "代えて", "に代えて", "代わって"
11. ほか: "ほか", "のほか"
12. 同様とする: "同様とする", "と同様に", "も、同様とする"
```

##### 条件・限定表現

```
13. 限定: "この限りでない", "限り", "に限って", "場合に限る", "に限り"
14. かかわらず: "にかかわらず", "かかわらず", "を問わず"
15. 関する: "に関して", "に関しては", "関する限り", "について", "については"
```

##### 規定参照の詳細表現

```
16. 規定: "の規定により", "規定による", "の規定に従い", "に規定する"
17. 定める: "定める", "定めるところにより", "別段の定め", "別に定める", "特別の定め"
18. ところ: "ところにより", "ところによる", "定めるところに従い"
```

##### 位置・構造参照

```
19. 前後参照: "前項", "前条", "次条", "同項", "同条"
20. 段落参照: "前段", "後段"
21. 列挙参照: "各号", "次に掲げる", "次の各号", "左に掲げる"
```

##### その他の参照表現

```
22. 応じて: "に応じて", "に応じ", "応じた"
23. 照らして: "に照らし", "に照らして", "鑑み", "鑑みて"
24. 該当: "該当する", "該当しない", "当たる", "当たらない"
25. 関わる: "に係る", "に関わる"
```

#### 5.2.2 Phase 1 の実装方針

##### 基本パターンマッチング

```javascript
// 基本的な参照パターン
const referencePatterns = [
  // 構造参照パターン
  {
    name: "article_reference",
    pattern: /第([一二三四五六七八九十百千]+|[0-9]+)条/g,
    type: "article",
  },
  {
    name: "paragraph_reference",
    pattern: /(前|次|同)項/g,
    type: "paragraph",
  },
  {
    name: "law_reference",
    pattern: /([\u4e00-\u9fa5]+法)(?:律)?(?:第([一二三四五六七八九十百千]+|[0-9]+)号)?/g,
    type: "law",
  },

  // 主要な参照タイプ
  {
    name: "apply_reference",
    pattern: /(?:について|を)?準用(?:する|し)/g,
    type: "APPLY",
  },
  {
    name: "deem_reference",
    pattern: /(?:と)?みなす|看做す/g,
    type: "DEEM",
  },
  {
    name: "replace_reference",
    pattern: /読み替え(?:る|て|るものとする)/g,
    type: "REPLACE",
  },
  {
    name: "except_reference",
    pattern: /(?:を|場合を)?除(?:く|き|いて)/g,
    type: "EXCEPT",
  },

  // 条件・限定表現
  {
    name: "limitation",
    pattern: /(?:この)?限り(?:で)?(?:ない)?/g,
    type: "LIMIT",
  },
  {
    name: "regardless",
    pattern: /(?:に)?かかわらず|を問わず/g,
    type: "REGARDLESS",
  },

  // 規定参照表現
  {
    name: "provision_reference",
    pattern: /(?:の)?規定(?:により|による|に従い|する)/g,
    type: "PROVISION",
  },
  {
    name: "stipulation",
    pattern: /定める(?:ところにより)?|別(?:段)?の定め|特別の定め/g,
    type: "STIPULATION",
  },
];

// 参照パターンの分類
const referenceCategories = {
  APPLY: ["準用"],
  DEEM: ["みなす", "看做す"],
  REPLACE: ["読み替え"],
  EXCEPT: ["除く", "除外"],
  FOLLOW: ["従う", "基づく", "よる"],
  LIMIT: ["限定", "限り"],
  RELATE: ["関する", "について"],
  STIPULATE: ["定める", "規定"],
};
```

##### ローカル LLM による参照解決（Phase 1）

```javascript
// Llama-3-ELYZA-JP-8Bを使用した参照解決
const LocalLLMResolver = {
  // Ollamaを使用したローカル実行
  async resolveReference(reference, context) {
    const prompt = `
法令文の参照を解決してください。

文脈: ${context.surroundingText}
参照テキスト: ${reference.text}
現在の法令: ${context.currentLaw}
現在の条文: ${context.currentArticle}

以下の形式でJSONを返してください:
{
  "targetLaw": "参照先の法令名（正式名称）",
  "targetArticle": "参照先の条番号",
  "confidence": 0.0-1.0,
  "reasoning": "判断理由"
}
`;

    const response = await ollama.generate({
      model: "llama3-elyza-jp-8b",
      prompt: prompt,
      format: "json",
      temperature: 0.1, // 確定的な出力のため低温度
    });

    return JSON.parse(response.response);
  },

  // 相対参照の解決
  async resolveRelativeReference(text, currentArticle) {
    const relativePatterns = {
      前条: currentArticle - 1,
      次条: currentArticle + 1,
      前項: "previous_paragraph",
      次項: "next_paragraph",
    };

    // 単純なパターンは直接解決
    if (relativePatterns[text]) {
      return { resolved: true, target: relativePatterns[text] };
    }

    // 複雑な場合はLLMに依頼
    return await this.resolveReference({ text }, { currentArticle });
  },
};
```

#### 5.2.3 参照解決ロジック

##### Phase 1: ローカル LLM を活用した解決

```javascript
class ReferenceResolver {
  constructor() {
    this.llm = new LocalLLMResolver();
    this.cache = new Map(); // 解決結果のキャッシュ
  }

  async resolve(reference, context) {
    // 1. キャッシュチェック
    const cacheKey = `${reference.text}_${context.lawId}_${context.articleId}`;
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }

    // 2. 基本パターンで解決を試みる
    const basicResult = this.tryBasicResolution(reference);
    if (basicResult.confidence > 0.9) {
      this.cache.set(cacheKey, basicResult);
      return basicResult;
    }

    // 3. ローカルLLMで解決
    const llmResult = await this.llm.resolveReference(reference, context);

    // 4. 信頼度が低い場合は人間レビュー用にマーク
    if (llmResult.confidence < 0.7) {
      llmResult.needsReview = true;
      llmResult.reviewReason = "低信頼度スコア";
    }

    this.cache.set(cacheKey, llmResult);
    return llmResult;
  }

  tryBasicResolution(reference) {
    // 明確なパターンの場合は高信頼度で返す
    if (reference.text.match(/^第\d+条$/)) {
      return {
        targetArticle: reference.text.match(/\d+/)[0],
        confidence: 0.95,
        method: "pattern_matching",
      };
    }

    return { confidence: 0 };
  }
}
```

主な処理フロー:

1. **パターンマッチング**: 明確な参照は正規表現で高速処理
2. **ローカル LLM 処理**: 曖昧な参照は Llama-3-ELYZA-JP-8B で解決
3. **キャッシング**: 同一参照の再計算を防止
4. **信頼度管理**: 低信頼度の結果は人間レビュー対象として記録

##### Phase 2: 商用 LLM 併用による高度な解決

参照解決には AI の活用が必須である。特に以下のケースで重要：

```javascript
// AI強化参照解決
async function enhanceReferenceWithAI(reference) {
  const context = extractContext(reference);

  // GPT-4oによる解析
  const aiAnalysis = await analyzeReference({
    text: reference.text,
    context: context,
    lawId: reference.lawId,
    surroundingText: reference.surroundingText,
  });

  return {
    ...reference,
    aiEnhanced: {
      targetLaw: aiAnalysis.targetLaw, // 正確な参照先法令
      targetArticles: aiAnalysis.targetArticles, // 参照先条文
      conditions: aiAnalysis.conditions, // 適用条件
      confidence: aiAnalysis.confidence, // 信頼度スコア
      reasoning: aiAnalysis.reasoning, // 推論過程
      ambiguityNotes: aiAnalysis.ambiguityNotes, // 曖昧性の注記
    },
  };
}
```

AI が解決すべき課題：

- 「前条」「当該規定」などの文脈依存参照
- 「本法」「この法律」の正確な特定
- 複雑な読み替え規定の構造解析
- 条件付き参照の条件抽出

### 5.3 改正影響分析アルゴリズム

```javascript
async function analyzeAmendmentImpact(amendedLawId, amendedArticles, depth = 3) {
  /**
   * 改正影響を分析する
   * @param {string} amendedLawId - 改正対象法令ID
   * @param {Array} amendedArticles - 改正対象条文リスト
   * @param {number} depth - 探索深度
   * @returns {Array} 影響を受ける法令・条文のリスト
   */
  const affected = new Set();
  const toCheck = [];

  // 初期ノードをキューに追加
  for (const article of amendedArticles) {
    toCheck.push({ article, depth: 0 });
  }

  while (toCheck.length > 0) {
    const { article: currentArticle, depth: currentDepth } = toCheck.shift();

    if (currentDepth >= depth) {
      continue;
    }

    // 逆方向の参照を取得
    const referencingArticles = await getArticlesReferringTo(currentArticle);

    for (const refArticle of referencingArticles) {
      if (!affected.has(refArticle)) {
        affected.add(refArticle);
        toCheck.push({ article: refArticle, depth: currentDepth + 1 });
      }
    }
  }

  return Array.from(affected);
}
```

## 6. インターフェース設計

### 6.1 画面設計

#### 6.1.1 法令検索画面

- 検索バー（キーワード、法令名、条番号）
- 検索結果一覧（ページネーション付き）
- フィルター（法令種別、公布年、施行状態）
- ソート機能（関連度、日付順）

#### 6.1.2 法令詳細画面

- 法令メタデータ表示
- 条文階層表示（ツリービュー）
- 参照関係表示（参照元/参照先）
- 改正履歴タイムライン

#### 6.1.3 改正影響分析画面

- 改正対象選択
- 影響範囲グラフ表示（ネットワーク図）
- 影響リスト（エクスポート機能付き）
- 分析パラメータ設定（探索深度等）

### 6.2 API 設計

#### 6.2.1 RESTful API エンドポイント

```yaml
# 法令関連
GET    /api/v1/laws                    # 法令一覧
GET    /api/v1/laws/{law_id}          # 法令詳細
GET    /api/v1/laws/{law_id}/articles # 条文一覧
POST   /api/v1/laws/search            # 法令検索

# 条文関連
GET    /api/v1/articles/{article_id}  # 条文詳細
GET    /api/v1/articles/{article_id}/references  # 参照関係

# 参照関係
GET    /api/v1/references/from/{article_id}  # 参照元
GET    /api/v1/references/to/{article_id}    # 参照先
POST   /api/v1/references/extract           # 参照抽出実行

# 分析
POST   /api/v1/analysis/impact              # 改正影響分析
POST   /api/v1/analysis/graph               # グラフデータ取得
```

#### 6.2.2 リクエスト/レスポンス仕様

```typescript
// 改正影響分析リクエスト
interface ImpactAnalysisRequest {
  amendedLawId: string;
  amendedArticles: number[];
  analysisDepth: number;
  includeIndirect: boolean;
  confidenceThreshold: number;
}

// 改正影響分析レスポンス
interface ImpactAnalysisResponse {
  summary: {
    totalAffectedLaws: number;
    totalAffectedArticles: number;
    directImpacts: number;
    indirectImpacts: number;
  };
  affectedItems: Array<{
    lawId: string;
    lawName: string;
    articles: Array<{
      articleId: string;
      articleNum: number;
      impactType: string;
      impactPath: string[];
      confidenceScore: number;
    }>;
  }>;
  visualizationData: {
    nodes: Array<GraphNode>;
    edges: Array<GraphEdge>;
  };
}
```

## 7. セキュリティ設計

### 7.1 認証・認可

#### 7.1.1 認証方式

- JWT（JSON Web Token）ベース認証
- トークン有効期限: 24 時間
- リフレッシュトークン: 7 日間

#### 7.1.2 権限モデル

| ロール | 権限                                       |
| ------ | ------------------------------------------ |
| 管理者 | 全機能アクセス、ユーザー管理、システム設定 |
| 編集者 | 参照関係の編集、AI 検証の実行、分析機能    |
| 閲覧者 | 法令閲覧、検索、基本的な分析機能           |

### 7.2 データ保護

- 通信: TLS 1.3 による HTTPS 通信
- データベース: 接続の暗号化（SSL/TLS）
- API: レート制限（1 分間 100 リクエスト）
- ログ: 個人情報のマスキング

## 8. 運用設計

### 8.1 デプロイメント

#### 8.1.1 Phase 1 インフラ構成

- **静的ホスティング**: Netlify / Vercel / GitHub Pages
- **CDN**: Cloudflare / Fastly
- **ビルド**: GitHub Actions
- **ストレージ**: 約 4GB（HTML + アセット）

#### 8.1.2 Phase 2 インフラ構成

- **クラウド**: Azure
- **コンテナ**: Docker + Kubernetes
- **CI/CD**: GitHub Actions + ArgoCD

#### 8.1.2 環境構成

| 環境         | 用途                   | スペック |
| ------------ | ---------------------- | -------- |
| 開発         | 開発・単体テスト       | 最小構成 |
| ステージング | 統合テスト・受入テスト | 本番同等 |
| 本番         | 実運用                 | 冗長構成 |

### 8.2 監視・ログ

#### 8.2.1 監視項目

- アプリケーション: APM（Datadog/New Relic）
- インフラ: CloudWatch/Stackdriver
- ログ: ELK スタック（Elasticsearch, Logstash, Kibana）

#### 8.2.2 アラート設定

- API 応答時間 > 3 秒
- エラー率 > 1%
- CPU 使用率 > 80%
- メモリ使用率 > 85%

### 8.3 バックアップ・リカバリ

#### 8.3.1 バックアップ方針

| データ        | 頻度       | 保持期間 |
| ------------- | ---------- | -------- |
| Neo4j         | 日次       | 30 日    |
| PostgreSQL    | 日次 + WAL | 30 日    |
| Elasticsearch | 週次       | 14 日    |

#### 8.3.2 災害復旧

- RPO（目標復旧時点）: 24 時間
- RTO（目標復旧時間）: 4 時間

## 9. テスト計画

### 9.1 テストレベル

#### 9.1.1 単体テスト

- カバレッジ目標: 80%以上
- テストフレームワーク: Jest（JavaScript）, Mocha + Chai

#### 9.1.2 統合テスト

- API 統合テスト: Postman/Newman
- E2E テスト: Cypress

#### 9.1.3 性能テスト

- 負荷テスト: JMeter/Locust
- 目標: 100 同時ユーザーで応答時間基準を満たす

### 9.2 テストデータ

- 本番相当の法令データ（約 10,000 件）
- 参照関係の多い法令を重点的に選定
- エッジケース（循環参照、多段参照）を含む

## 10. プロジェクト計画

### 10.1 フェーズ分け

#### Phase 1: 静的法令閲覧サイト（3 ヶ月）

**目的**: 法令間の参照関係を可視化した静的サイトを構築し、一般公開する

**月次計画**:

- **1 ヶ月目**: データ処理基盤

  - XML パーサー開発（Node.js）
  - 参照関係抽出エンジン実装
  - 基本的なリンク生成ロジック

- **2 ヶ月目**: 静的サイト生成

  - HTML テンプレート設計
  - 静的サイト生成スクリプト開発
  - クライアントサイド検索機能実装
  - レスポンシブデザイン対応

- **3 ヶ月目**: 公開準備
  - パフォーマンス最適化
  - SEO 対策
  - CDN セットアップ
  - ドキュメント整備

**成果物**:

- 全法令の静的 HTML ファイル（約 1 万ファイルを個別管理）
- 法令間の自動リンク機能（ローカル LLM で強化）
- クライアントサイド検索（分割インデックスで高速化）
- CDN 配信による高速アクセス
- PWA 化によるオフライン対応

**大規模データ対応**:

- 3.2GB のデータを 1 万個の小さな HTML ファイルに分割
- Lazy Loading で必要な法令のみオンデマンド読み込み
- Service Worker によるインテリジェントキャッシュ
- 検索インデックスの圧縮配信

#### Phase 2: 法令改正支援システム（3-4 ヶ月）

**目的**: 役所向けの高度な法令改正支援機能を提供

**月次計画**:

- **1 ヶ月目**: バックエンド基盤

  - Express.js API サーバー構築
  - Neo4j グラフ DB 実装
  - 認証・権限管理システム

- **2 ヶ月目**: コア機能実装

  - ハネ改正検出エンジン
  - 改正影響分析機能
  - GPT-4o 統合（AI 検証）

- **3 ヶ月目**: 管理画面開発

  - React 管理画面 UI
  - 改正シミュレーション機能
  - レポート生成機能

- **4 ヶ月目**: 統合・最適化
  - システム統合テスト
  - パフォーマンスチューニング
  - セキュリティ監査

**成果物**:

- RESTful API
- 管理者向け Web アプリケーション
- ハネ改正自動検出
- AI 支援による参照関係検証

### 10.2 リスク管理

| リスク            | 影響 | 発生確率 | 対策                               |
| ----------------- | ---- | -------- | ---------------------------------- |
| AI API コスト超過 | 高   | 中       | 使用量上限設定、キャッシング強化   |
| 参照抽出精度不足  | 高   | 中       | 段階的な精度向上、人手レビュー     |
| 性能要件未達      | 中   | 低       | 早期性能テスト、スケールアウト設計 |
| 法令形式変更      | 中   | 低       | 柔軟なパーサー設計、変更監視       |

## 11. 成功指標

### 11.1 Phase 1 の成功指標

#### 定量的指標

- 静的サイト生成時間: 全法令で 60 分以内（ローカル LLM 処理含む）
- 初期ページ読み込み: 1 秒以内（コアファイルのみ）
- 法令詳細表示: 2 秒以内（CDN + Lazy Loading）
- リンク抽出精度: 90%以上（ローカル LLM 活用）
- 月間ページビュー: 10 万 PV（公開 6 ヶ月後）
- 平均滞在時間: 5 分以上
- オフライン利用率: 30%（PWA でキャッシュ済み）

#### 定性的指標

- 法令間の関係性が一目で分かる
- 参照先へのナビゲーションが容易
- モバイルでも快適に閲覧可能

### 11.2 Phase 2 の成功指標

#### 定量的指標

- ハネ改正検出精度: 95%以上
- 改正影響分析の実行時間: 5 秒以内（深度 3）
- システム稼働率: 99.5%以上
- API 応答時間: 1 秒以内（95 パーセンタイル）

#### 定性的指標

- 10 省庁以上での導入実績
- 法令改正作業時間の 50%削減
- ハネ改正の見落としゼロ
- ユーザー満足度: 80%以上

## 12. 制約事項と前提条件

### 12.1 制約事項

- 政府標準 XML 形式に依存
- OpenAI API の利用制限
- 個人情報を含む法令データは扱わない

### 12.2 前提条件

- 法令 XML データへのアクセス権限
- 十分な AI API 利用予算
- 専門知識を持つ法務担当者の協力

## 13. 用語集

| 用語     | 説明                                               |
| -------- | -------------------------------------------------- |
| ハネ改正 | ある法令の改正が他の法令に波及的に影響を与えること |
| 準用     | 他の法令の規定をそのまま適用すること               |
| みなす   | 法律上、あるものを別のものとして扱うこと           |
| 読み替え | 条文中の文言を別の文言に置き換えて適用すること     |

## 14. 付録

### 14.1 参考資料

- 政府標準法令 XML スキーマ仕様書
- e-Gov 法令検索 API 仕槕
- OpenAI GPT-4o API ドキュメント

### 14.2 関連システム

- e-Gov 法令検索システム
- 各省庁法令データベース
- 法令執務支援システム

## 15. 設計根拠と技術選定理由

### 15.1 フェーズ分割の根拠

2 フェーズ構成を採用した理由：

1. **早期価値提供**: Phase 1 の静的サイトで法令間の関係性をすぐに可視化
2. **リスク低減**: 最小限のインフラで開始し、段階的に拡張
3. **フィードバック収集**: Phase 1 の利用者からのフィードバックを Phase 2 に反映
4. **コスト効率**: 静的ホスティングで運用コストを最小化

### 15.2 グラフ DB（Neo4j）選定の詳細根拠

#### 法令データの特性

法令間の参照関係は以下の特徴を持つ：

- **多対多の複雑な関係**: 一つの法令が複数の法令を参照し、複数から参照される
- **階層的な参照**: A→B→C といった連鎖的な参照
- **動的な関係性**: 法改正により参照関係が変化

#### グラフ DB の具体的メリット

```cypher
// ハネ改正の影響範囲を高速に探索
MATCH (law:Law {law_id: '132AC0000000048'})-[:REFERENCES*1..3]->(affected:Law)
RETURN DISTINCT affected
// RDBMSでは複雑な再帰CTEが必要
```

#### デメリットへの対応策

1. **学習コスト**:

   - Cypher クエリのチートシートとサンプル集を整備
   - OGM（Object-Graph Mapping）ライブラリの活用

2. **運用コスト**:

   - Community Edition で開始し、必要に応じて Enterprise へ移行
   - クラウド版（Neo4j Aura）の検討

3. **ハイブリッド構成**:
   - メタデータと統計情報は PostgreSQL
   - 参照関係のみを Neo4j で管理

### 15.3 AI 活用の必要性とローカル LLM 採用理由

#### 参照解決における AI の役割

1. **文脈依存参照の解決**

   - 「前条」「当該規定」などの曖昧な参照
   - 法令名の略称や俗称の正規化

2. **複雑な読み替え規定の解析**

   - 複数の読み替えが絡み合う場合
   - 条件付き読み替えの条件抽出

3. **参照関係の検証**
   - 抽出した参照の妥当性確認
   - 誤った参照の検出と修正提案

#### Phase 1 でのローカル LLM（Llama-3-ELYZA-JP-8B）採用理由

1. **コスト効率**

   - API コール料金が不要
   - 大量の法令データ処理でも追加コストなし
   - 静的サイト生成時の一括処理に最適

2. **性能特性**

   - 8B パラメータで高品質な日本語理解
   - ELYZA 社による日本語特化チューニング
   - 法令文書のような形式的な文章に適合

3. **運用上のメリット**

   - オフライン環境での動作可能
   - データプライバシーの完全な確保
   - レスポンス速度の安定性（ネットワーク遅延なし）

4. **実装の容易さ**

   - Ollama による簡単なセットアップ
   - Node.js からの直接呼び出し可能
   - バッチ処理との親和性が高い

5. **段階的な品質向上**
   - Phase 1 で基本的な参照解決を実現
   - Phase 2 で GPT-4o による高度な解析を追加
   - 問題のあるパターンを特定してから商用 LLM を適用

### 15.4 法令部分間参照のグラフ DB 実装設計

#### 詳細な参照関係の表現要件

法令の参照関係は単純な条文間リンクではなく、以下の詳細な要素を含む：

1. **参照の粒度**

   - 法令レベル：「○○ 法による」
   - 条レベル：「第 3 条の規定により」
   - 項レベル：「第 2 項の規定を準用する」
   - 号レベル：「第 1 号に掲げる場合」

2. **参照の方向性**

   - 呼び出し参照（Outgoing）：ある条文が他を参照
   - 呼び出され参照（Incoming）：ある条文が他から参照される
   - 双方向参照：相互に参照し合う関係

3. **参照の種別**
   - 準用：他の規定をそのまま適用
   - 読み替え：文言を置き換えて適用
   - みなす：法的擬制による参照
   - 例による：手続きや基準の参照

#### グラフ DB での実装アプローチ

##### 1. 階層的ノード設計

```cypher
// 法令の各レベルを独立したノードとして管理
(:Law) -[:HAS_ARTICLE]-> (:Article) -[:HAS_PARAGRAPH]-> (:Paragraph) -[:HAS_ITEM]-> (:Item)
```

この設計により：

- 任意の粒度での参照が可能
- 条文の一部のみを参照する場合も正確に表現
- 将来的な構造変更にも柔軟に対応

##### 2. リッチな参照リレーション

```cypher
(:Article)-[:REFERENCES {
    // 基本情報
    reference_id: String,           // 一意識別子
    source_text: String,           // 元の参照テキスト

    // 参照の詳細仕様
    primary_type: String,          // APPLY, DEEM, REPLACE等
    target_specification: {
        level: String,             // article, paragraph, item
        numbers: [Integer],        // 複数指定可能（第1項及び第3項等）
        range: {start: Int, end: Int}  // 範囲指定（第1項から第5項まで）
    },

    // 条件と制約
    conditions: [String],          // 適用条件のリスト
    exceptions: [String],          // 例外事項
    temporal_scope: {              // 時限的な参照
        start_date: Date,
        end_date: Date
    },

    // AI解析メタデータ
    ai_analysis: {
        confidence: Float,         // 0.0-1.0の信頼度
        ambiguity_level: String,   // HIGH, MEDIUM, LOW
        resolution_notes: String,  // 解決時の注記
        llm_model: String,        // 使用したLLMモデル
        analyzed_at: DateTime
    }
}]->(:Article)
```

##### 3. 実用的なクエリパターン

```cypher
// ハネ改正の完全な影響分析
MATCH path = (amended:Article {article_id: $articleId})<-[:REFERENCES*1..5]-(affected)
WHERE ALL(rel IN relationships(path) WHERE rel.ai_analysis.confidence > 0.7)
WITH path, affected,
     [rel IN relationships(path) | rel.primary_type] as referenceChain,
     reduce(conf = 1.0, rel IN relationships(path) | conf * rel.ai_analysis.confidence) as pathConfidence
RETURN affected, referenceChain, pathConfidence, length(path) as depth
ORDER BY depth, pathConfidence DESC;
```

#### 実装上の利点

1. **パフォーマンス**

   - インデックストラバーサルによる高速な参照探索
   - 複雑な再帰クエリをシンプルなパスクエリで実現
   - キャッシュ効率の良いグラフ構造

2. **保守性**

   - スキーマレスな特性により新しい参照パターンへの対応が容易
   - プロパティグラフモデルによる豊富なメタデータ管理
   - バージョン管理や履歴追跡の実装が簡単

3. **分析能力**

   - グラフアルゴリズム（中心性、クラスタリング等）の活用
   - 視覚化ツールとの親和性が高い
   - 複雑な参照パターンの発見が可能

4. **スケーラビリティ**
   - 法令数の増加に対してリニアにスケール
   - シャーディングによる水平分割が可能
   - 読み取り専用レプリカによる負荷分散

## 16. 改訂履歴

| バージョン | 日付       | 変更内容                                                                                                                                 |
| ---------- | ---------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| 1.0        | 2025-08-02 | 初版作成                                                                                                                                 |
| 1.1        | 2025-08-02 | フェーズ戦略を反映、設計根拠を追加                                                                                                       |
| 1.2        | 2025-08-03 | 法令部分間参照のグラフ DB 実装設計を追加                                                                                                 |
| 1.3        | 2025-08-03 | 参照パターンの詳細分類を追加（25 種類に拡張）                                                                                            |
| 1.4        | 2025-08-03 | 法令 API（https://laws.e-gov.go.jp/api/2/swagger-ui/）対応設計を追加：データソース抽象化、API経由の継続更新、レート制限管理、API履歴管理 |

# クラス設計書

**作成日**: 2025年8月3日  
**バージョン**: 1.0  
**プロジェクト名**: LawFinder

## 1. 概要

本ドキュメントは、LawFinderシステムのオブジェクト指向設計を定義する。ドメイン駆動設計（DDD）の原則に従い、ビジネスロジックをドメインモデルに集約し、保守性と拡張性の高いアーキテクチャを実現する。

### 1.1 設計方針

1. **レイヤードアーキテクチャ**: プレゼンテーション層、アプリケーション層、ドメイン層、インフラストラクチャ層の4層構造
2. **依存性逆転の原則**: 上位層は下位層に依存せず、抽象に依存
3. **単一責任の原則**: 各クラスは1つの責任のみを持つ
4. **インターフェース分離**: 必要最小限のインターフェースを定義
5. **テスタビリティ**: 依存性注入によりテスト容易性を確保

### 1.2 技術スタック

- **言語**: TypeScript 5.x / JavaScript (Node.js 18.x)
- **フレームワーク**: Express.js / NestJS（Phase 2）
- **ORM/ODM**: Prisma (PostgreSQL), Neo4j Driver
- **バリデーション**: class-validator, Joi
- **DI コンテナ**: InversifyJS（Phase 2）

## 2. パッケージ構造

```
src/
├── domain/                 # ドメイン層
│   ├── models/            # ドメインモデル
│   ├── repositories/      # リポジトリインターフェース
│   ├── services/          # ドメインサービス
│   └── value-objects/     # 値オブジェクト
├── application/           # アプリケーション層
│   ├── use-cases/        # ユースケース
│   ├── dto/              # データ転送オブジェクト
│   └── services/         # アプリケーションサービス
├── infrastructure/        # インフラストラクチャ層
│   ├── persistence/      # データ永続化実装
│   ├── external/         # 外部サービス連携
│   └── config/           # 設定
├── presentation/          # プレゼンテーション層
│   ├── controllers/      # APIコントローラー
│   ├── middlewares/      # ミドルウェア
│   └── validators/       # 入力検証
└── shared/               # 共通ユーティリティ
    ├── errors/          # カスタムエラー
    ├── types/           # 型定義
    └── utils/           # ユーティリティ関数
```

## 3. ドメインモデル設計

### 3.1 エンティティ

#### 3.1.1 Law（法令）エンティティ

```typescript
// domain/models/Law.ts
export class Law {
    private constructor(
        private readonly id: LawId,
        private title: LawTitle,
        private type: LawType,
        private status: LawStatus,
        private readonly promulgateDate: Date,
        private enforceDate: Date | null,
        private articles: Article[],
        private readonly createdAt: Date,
        private updatedAt: Date
    ) {}

    // ファクトリメソッド
    static create(params: CreateLawParams): Law {
        const id = LawId.generate(params.type, params.year, params.number);
        const title = new LawTitle(params.title, params.titleKana);
        
        return new Law(
            id,
            title,
            params.type,
            LawStatus.NotYetEnforced,
            params.promulgateDate,
            null,
            [],
            new Date(),
            new Date()
        );
    }

    // ビジネスロジック
    enforce(date: Date): void {
        if (this.status !== LawStatus.NotYetEnforced) {
            throw new DomainError('既に施行されている法令です');
        }
        if (date < this.promulgateDate) {
            throw new DomainError('施行日は公布日より後である必要があります');
        }
        
        this.enforceDate = date;
        this.status = LawStatus.Active;
        this.updatedAt = new Date();
    }

    repeal(date: Date): void {
        if (this.status === LawStatus.Repealed) {
            throw new DomainError('既に廃止されている法令です');
        }
        
        this.status = LawStatus.Repealed;
        this.updatedAt = new Date();
    }

    addArticle(article: Article): void {
        const existingArticle = this.articles.find(a => a.number === article.number);
        if (existingArticle) {
            throw new DomainError(`条番号 ${article.number} は既に存在します`);
        }
        
        this.articles.push(article);
        this.articles.sort((a, b) => a.number - b.number);
        this.updatedAt = new Date();
    }

    // ゲッター
    get lawId(): string {
        return this.id.value;
    }

    get lawTitle(): string {
        return this.title.value;
    }

    get articleCount(): number {
        return this.articles.length;
    }

    toJSON(): LawData {
        return {
            lawId: this.id.value,
            lawType: this.type,
            lawTitle: this.title.value,
            lawTitleKana: this.title.kana,
            status: this.status,
            promulgateDate: this.promulgateDate,
            enforceDate: this.enforceDate,
            articleCount: this.articles.length,
            createdAt: this.createdAt,
            updatedAt: this.updatedAt
        };
    }
}
```

#### 3.1.2 Article（条文）エンティティ

```typescript
// domain/models/Article.ts
export class Article {
    private references: Reference[] = [];
    
    constructor(
        private readonly id: ArticleId,
        private readonly lawId: LawId,
        public readonly number: number,
        private title: string | null,
        private paragraphs: Paragraph[],
        private readonly createdAt: Date
    ) {}

    static create(lawId: LawId, number: number, title?: string): Article {
        const id = ArticleId.generate(lawId, number);
        return new Article(id, lawId, number, title || null, [], new Date());
    }

    addParagraph(content: string): Paragraph {
        const number = this.paragraphs.length + 1;
        const paragraph = Paragraph.create(this.id, number, content);
        this.paragraphs.push(paragraph);
        return paragraph;
    }

    addReference(reference: Reference): void {
        this.references.push(reference);
    }

    getOutgoingReferences(): Reference[] {
        return this.references.filter(ref => ref.isOutgoing(this.id));
    }

    getIncomingReferences(): Reference[] {
        return this.references.filter(ref => ref.isIncoming(this.id));
    }

    get fullText(): string {
        return this.paragraphs.map(p => p.content).join('\n');
    }
}
```

#### 3.1.3 Reference（参照関係）エンティティ

```typescript
// domain/models/Reference.ts
export class Reference {
    constructor(
        private readonly id: ReferenceId,
        private readonly source: ReferenceNode,
        private readonly target: ReferenceNode,
        private readonly type: ReferenceType,
        private readonly sourceText: string,
        private confidence: number,
        private aiAnalysis: AIAnalysisResult | null,
        private humanVerified: boolean,
        private readonly createdAt: Date
    ) {}

    static create(params: CreateReferenceParams): Reference {
        const id = ReferenceId.generate();
        return new Reference(
            id,
            params.source,
            params.target,
            params.type,
            params.sourceText,
            params.confidence || 0,
            null,
            false,
            new Date()
        );
    }

    verify(userId: string, notes?: string): void {
        this.humanVerified = true;
        this.confidence = 1.0;
    }

    updateAIAnalysis(analysis: AIAnalysisResult): void {
        this.aiAnalysis = analysis;
        this.confidence = analysis.confidence;
    }

    isOutgoing(nodeId: string): boolean {
        return this.source.id === nodeId;
    }

    isIncoming(nodeId: string): boolean {
        return this.target.id === nodeId;
    }

    get isPrimaryType(): boolean {
        return PRIMARY_REFERENCE_TYPES.includes(this.type);
    }

    get needsReview(): boolean {
        return this.confidence < 0.7 && !this.humanVerified;
    }
}
```

### 3.2 値オブジェクト

#### 3.2.1 LawId（法令ID）

```typescript
// domain/value-objects/LawId.ts
export class LawId {
    private static readonly PATTERN = /^\d{3}[A-Z]{2}\d{10}$/;
    
    constructor(private readonly _value: string) {
        if (!LawId.isValid(_value)) {
            throw new InvalidLawIdError(_value);
        }
    }

    static generate(type: LawType, year: number, number: number): LawId {
        const typeCode = LAW_TYPE_CODES[type];
        const yearStr = year.toString().padStart(3, '0');
        const numStr = number.toString().padStart(10, '0');
        return new LawId(`${yearStr}${typeCode}${numStr}`);
    }

    static isValid(value: string): boolean {
        return LawId.PATTERN.test(value);
    }

    get value(): string {
        return this._value;
    }

    equals(other: LawId): boolean {
        return this._value === other._value;
    }
}
```

#### 3.2.2 LawTitle（法令名）

```typescript
// domain/value-objects/LawTitle.ts
export class LawTitle {
    constructor(
        private readonly _value: string,
        private readonly _kana: string | null = null
    ) {
        if (!_value || _value.length > 500) {
            throw new InvalidLawTitleError(_value);
        }
    }

    get value(): string {
        return this._value;
    }

    get kana(): string | null {
        return this._kana;
    }

    getAbbreviation(): string {
        // 略称生成ロジック
        return this._value.replace(/に関する法律$/, '法');
    }
}
```

#### 3.2.3 ReferenceType（参照タイプ）

```typescript
// domain/value-objects/ReferenceType.ts
export enum ReferenceType {
    // 主要タイプ
    APPLY = 'APPLY',           // 準用
    DEEM = 'DEEM',            // みなす
    REPLACE = 'REPLACE',       // 読み替え
    EXCEPT = 'EXCEPT',         // 除外
    FOLLOW = 'FOLLOW',         // 従う・基づく
    LIMIT = 'LIMIT',           // 限定
    REGARDLESS = 'REGARDLESS', // 無関係（かかわらず）
    RELATE = 'RELATE',         // 関係
    STIPULATE = 'STIPULATE',   // 規定
    EXAMPLE = 'EXAMPLE',       // 例示
    SIMILAR = 'SIMILAR',       // 同様
    SUBSTITUTE = 'SUBSTITUTE', // 代替
    ADDITION = 'ADDITION'      // 追加
}

export const PRIMARY_REFERENCE_TYPES = [
    ReferenceType.APPLY,
    ReferenceType.DEEM,
    ReferenceType.REPLACE,
    ReferenceType.EXCEPT
];

export class ReferenceTypeClassifier {
    static classify(text: string): ReferenceType[] {
        const types: ReferenceType[] = [];
        
        if (/準用/.test(text)) types.push(ReferenceType.APPLY);
        if (/みなす|看做す/.test(text)) types.push(ReferenceType.DEEM);
        if (/読み替え/.test(text)) types.push(ReferenceType.REPLACE);
        if (/除く|除き/.test(text)) types.push(ReferenceType.EXCEPT);
        if (/従い|従う|基づ/.test(text)) types.push(ReferenceType.FOLLOW);
        if (/限り|限って/.test(text)) types.push(ReferenceType.LIMIT);
        if (/かかわらず|問わず/.test(text)) types.push(ReferenceType.REGARDLESS);
        
        return types.length > 0 ? types : [ReferenceType.RELATE];
    }
}
```

### 3.3 ドメインサービス

#### 3.3.1 参照解析サービス

```typescript
// domain/services/ReferenceAnalysisService.ts
export class ReferenceAnalysisService {
    constructor(
        private readonly patternMatcher: PatternMatcher,
        private readonly aiResolver: AIReferenceResolver,
        private readonly referenceRepository: ReferenceRepository
    ) {}

    async analyzeArticle(article: Article): Promise<Reference[]> {
        const references: Reference[] = [];
        
        // 1. パターンマッチング
        const patterns = this.patternMatcher.findPatterns(article.fullText);
        
        // 2. 参照解決
        for (const pattern of patterns) {
            const resolved = await this.resolveReference(pattern, article);
            if (resolved) {
                references.push(resolved);
            }
        }
        
        // 3. 重複除去と統合
        return this.consolidateReferences(references);
    }

    private async resolveReference(
        pattern: MatchedPattern,
        sourceArticle: Article
    ): Promise<Reference | null> {
        // 基本的な解決を試みる
        const basicResolution = this.tryBasicResolution(pattern, sourceArticle);
        
        if (basicResolution && basicResolution.confidence > 0.9) {
            return basicResolution;
        }
        
        // AI による解決
        const aiResolution = await this.aiResolver.resolve(pattern, sourceArticle);
        
        if (aiResolution.confidence < 0.5) {
            return null; // 信頼度が低すぎる場合は除外
        }
        
        return aiResolution;
    }

    private consolidateReferences(references: Reference[]): Reference[] {
        // 同一参照の統合ロジック
        const grouped = new Map<string, Reference[]>();
        
        for (const ref of references) {
            const key = `${ref.source.id}_${ref.target.id}_${ref.type}`;
            const group = grouped.get(key) || [];
            group.push(ref);
            grouped.set(key, group);
        }
        
        return Array.from(grouped.values()).map(group => {
            if (group.length === 1) return group[0];
            
            // 最も信頼度の高いものを選択
            return group.reduce((best, current) => 
                current.confidence > best.confidence ? current : best
            );
        });
    }
}
```

#### 3.3.2 影響分析サービス

```typescript
// domain/services/ImpactAnalysisService.ts
export class ImpactAnalysisService {
    constructor(
        private readonly referenceRepository: ReferenceRepository,
        private readonly lawRepository: LawRepository
    ) {}

    async analyzeAmendmentImpact(
        amendedLawId: LawId,
        amendedArticles: number[],
        options: ImpactAnalysisOptions = {}
    ): Promise<ImpactAnalysisResult> {
        const depth = options.depth || 3;
        const includeIndirect = options.includeIndirect ?? true;
        const confidenceThreshold = options.confidenceThreshold || 0.7;
        
        const impactedNodes = new Map<string, ImpactedNode>();
        const toProcess: ProcessingNode[] = [];
        
        // 初期ノードの設定
        for (const articleNum of amendedArticles) {
            const articleId = ArticleId.generate(amendedLawId, articleNum);
            toProcess.push({
                nodeId: articleId.value,
                nodeType: 'article',
                depth: 0,
                path: [articleId.value]
            });
        }
        
        // 幅優先探索で影響を分析
        while (toProcess.length > 0) {
            const current = toProcess.shift()!;
            
            if (current.depth >= depth) continue;
            
            // 参照元を取得
            const references = await this.referenceRepository.findIncoming(
                current.nodeId,
                { minConfidence: confidenceThreshold }
            );
            
            for (const ref of references) {
                const impactedId = ref.source.id;
                
                if (!impactedNodes.has(impactedId)) {
                    const impacted: ImpactedNode = {
                        nodeId: impactedId,
                        nodeType: ref.source.type,
                        impactType: this.determineImpactType(ref),
                        impactPath: [...current.path, impactedId],
                        confidence: ref.confidence * (0.9 ** current.depth),
                        depth: current.depth + 1
                    };
                    
                    impactedNodes.set(impactedId, impacted);
                    
                    if (includeIndirect) {
                        toProcess.push({
                            nodeId: impactedId,
                            nodeType: ref.source.type,
                            depth: current.depth + 1,
                            path: impacted.impactPath
                        });
                    }
                }
            }
        }
        
        return this.buildAnalysisResult(impactedNodes, amendedLawId, amendedArticles);
    }

    private determineImpactType(reference: Reference): ImpactType {
        switch (reference.type) {
            case ReferenceType.APPLY:
                return ImpactType.DirectApplication;
            case ReferenceType.REPLACE:
                return ImpactType.TextReplacement;
            case ReferenceType.DEEM:
                return ImpactType.LegalFiction;
            case ReferenceType.EXCEPT:
                return ImpactType.Exception;
            default:
                return ImpactType.General;
        }
    }
}
```

### 3.4 リポジトリインターフェース

#### 3.4.1 法令リポジトリ

```typescript
// domain/repositories/LawRepository.ts
export interface LawRepository {
    findById(id: LawId): Promise<Law | null>;
    findByIds(ids: LawId[]): Promise<Law[]>;
    findByType(type: LawType, options?: FindOptions): Promise<Law[]>;
    findUpdatedSince(date: Date, options?: FindOptions): Promise<Law[]>;
    save(law: Law): Promise<void>;
    saveAll(laws: Law[]): Promise<void>;
    count(): Promise<number>;
    countByStatus(status: LawStatus): Promise<number>;
    countBySource(source: string, month?: Date): Promise<number>;
}

export interface FindOptions {
    limit?: number;
    offset?: number;
    orderBy?: string;
    orderDirection?: 'asc' | 'desc';
}
```

#### 3.4.2 参照リポジトリ

```typescript
// domain/repositories/ReferenceRepository.ts
export interface ReferenceRepository {
    findById(id: ReferenceId): Promise<Reference | null>;
    findByLaw(lawId: LawId): Promise<Reference[]>;
    findOutgoing(nodeId: string, options?: ReferenceQueryOptions): Promise<Reference[]>;
    findIncoming(nodeId: string, options?: ReferenceQueryOptions): Promise<Reference[]>;
    findLowConfidence(threshold: number): Promise<Reference[]>;
    save(reference: Reference): Promise<void>;
    saveAll(references: Reference[]): Promise<void>;
    update(reference: Reference): Promise<void>;
    delete(id: ReferenceId): Promise<void>;
    countVerified(): Promise<number>;
    countLowConfidence(): Promise<number>;
    countByType(): Promise<Record<ReferenceType, number>>;
}

export interface ReferenceQueryOptions {
    minConfidence?: number;
    referenceTypes?: ReferenceType[];
    verifiedOnly?: boolean;
    limit?: number;
}
```

#### 3.4.3 データソースインターフェース

```typescript
// domain/repositories/DataSource.ts
export interface LawDataSource {
    readonly type: 'xml' | 'api';
    fetchLawList(options?: FetchOptions): Promise<LawListResult>;
    fetchLawDetail(lawId: string): Promise<LawData>;
    fetchUpdatedLaws(since: Date): Promise<LawListResult>;
}

export interface FetchOptions {
    limit?: number;
    offset?: number;
    updatedSince?: Date;
}

export interface LawListResult {
    laws: LawListItem[];
    hasMore: boolean;
    nextOffset?: number;
}

export interface LawListItem {
    lawId: string;
    lawTitle: string;
    lastModified: string;
    source: 'xml' | 'api';
}

export interface LawData {
    lawId: string;
    lawType: string;
    lawTitle: string;
    lawTitleKana: string | null;
    promulgateDate: Date;
    enforceDate: Date | null;
    articles: ArticleData[];
    source: 'xml' | 'api';
    lastModified: Date;
}
```

## 4. アプリケーション層設計

### 4.1 ユースケース

#### 4.1.1 法令検索ユースケース

```typescript
// application/use-cases/SearchLawsUseCase.ts
export class SearchLawsUseCase {
    constructor(
        private readonly lawRepository: LawRepository,
        private readonly searchService: SearchService
    ) {}

    async execute(query: SearchLawsQuery): Promise<SearchLawsResult> {
        // 入力検証
        const validatedQuery = this.validateQuery(query);
        
        // 検索実行
        const searchResult = await this.searchService.searchLaws(
            validatedQuery.keyword,
            {
                lawType: validatedQuery.lawType,
                status: validatedQuery.status,
                dateRange: validatedQuery.dateRange
            }
        );
        
        // 詳細データ取得
        const laws = await this.lawRepository.findByIds(
            searchResult.lawIds.map(id => new LawId(id))
        );
        
        // 結果の整形
        return {
            laws: laws.map(law => this.toLawDTO(law)),
            totalCount: searchResult.totalCount,
            facets: searchResult.facets
        };
    }

    private validateQuery(query: SearchLawsQuery): ValidatedSearchQuery {
        if (!query.keyword || query.keyword.length < 2) {
            throw new ValidationError('検索キーワードは2文字以上必要です');
        }
        
        return {
            keyword: query.keyword,
            lawType: query.lawType,
            status: query.status || 'active',
            dateRange: query.dateRange,
            page: Math.max(1, query.page || 1),
            limit: Math.min(100, query.limit || 20)
        };
    }

    private toLawDTO(law: Law): LawDTO {
        return {
            lawId: law.lawId,
            lawTitle: law.lawTitle,
            lawType: law.type,
            status: law.status,
            promulgateDate: law.promulgateDate.toISOString(),
            articleCount: law.articleCount
        };
    }
}
```

#### 4.1.2 参照関係抽出ユースケース

```typescript
// application/use-cases/ExtractReferencesUseCase.ts
export class ExtractReferencesUseCase {
    constructor(
        private readonly lawRepository: LawRepository,
        private readonly referenceAnalysisService: ReferenceAnalysisService,
        private readonly referenceRepository: ReferenceRepository,
        private readonly eventBus: EventBus
    ) {}

    async execute(command: ExtractReferencesCommand): Promise<ExtractReferencesResult> {
        // 法令取得
        const law = await this.lawRepository.findById(new LawId(command.lawId));
        if (!law) {
            throw new NotFoundError(`法令が見つかりません: ${command.lawId}`);
        }
        
        const extractedReferences: Reference[] = [];
        const errors: ExtractionError[] = [];
        
        // 各条文の参照を抽出
        for (const article of law.articles) {
            try {
                const references = await this.referenceAnalysisService.analyzeArticle(article);
                extractedReferences.push(...references);
                
                // リポジトリに保存
                await this.referenceRepository.saveAll(references);
            } catch (error) {
                errors.push({
                    articleId: article.id,
                    articleNum: article.number,
                    error: error.message
                });
            }
        }
        
        // イベント発行
        await this.eventBus.publish(new ReferencesExtractedEvent({
            lawId: command.lawId,
            referenceCount: extractedReferences.length,
            errorCount: errors.length
        }));
        
        return {
            lawId: command.lawId,
            extractedCount: extractedReferences.length,
            errors: errors,
            lowConfidenceCount: extractedReferences.filter(r => r.needsReview).length
        };
    }
}
```

### 4.2 DTOとマッパー

```typescript
// application/dto/LawDTO.ts
export interface LawDTO {
    lawId: string;
    lawType: string;
    lawTitle: string;
    lawTitleKana?: string;
    status: string;
    promulgateDate: string;
    enforceDate?: string;
    articleCount: number;
    referenceCount?: number;
}

// application/mappers/LawMapper.ts
export class LawMapper {
    static toDTO(law: Law, includeReferences = false): LawDTO {
        return {
            lawId: law.lawId,
            lawType: law.type,
            lawTitle: law.lawTitle,
            lawTitleKana: law.lawTitleKana,
            status: law.status,
            promulgateDate: law.promulgateDate.toISOString(),
            enforceDate: law.enforceDate?.toISOString(),
            articleCount: law.articleCount,
            referenceCount: includeReferences ? law.referenceCount : undefined
        };
    }

    static toDomain(dto: LawDTO): Law {
        return Law.reconstruct({
            id: new LawId(dto.lawId),
            title: new LawTitle(dto.lawTitle, dto.lawTitleKana),
            type: dto.lawType as LawType,
            status: dto.status as LawStatus,
            promulgateDate: new Date(dto.promulgateDate),
            enforceDate: dto.enforceDate ? new Date(dto.enforceDate) : null
        });
    }
}
```

## 5. インフラストラクチャ層設計

### 5.1 データソース実装

#### 5.1.1 データソースファクトリ

```typescript
// infrastructure/persistence/DataSourceFactory.ts
export class DataSourceFactory {
    constructor(
        private readonly config: Configuration,
        private readonly cacheService: CacheService
    ) {}

    createXMLSource(): LawDataSource {
        return new XMLFileDataSource(this.config.dataPath.xmlDirectory);
    }

    createAPISource(): LawDataSource {
        const apiClient = new LawAPIClient(this.config.api);
        return new APIDataSource(apiClient, this.cacheService);
    }

    createHybridSource(options: HybridSourceOptions): LawDataSource {
        const xmlSource = this.createXMLSource();
        const apiSource = this.createAPISource();
        return new HybridDataSource(xmlSource, apiSource, options);
    }
}
```

#### 5.1.2 XMLファイルデータソース

```typescript
// infrastructure/persistence/XMLFileDataSource.ts
export class XMLFileDataSource implements LawDataSource {
    readonly type = 'xml' as const;
    
    constructor(
        private readonly xmlDirectory: string,
        private readonly parser: XMLParser = new XMLParser()
    ) {}
    
    async fetchLawList(options?: FetchOptions): Promise<LawListResult> {
        const files = await fs.readdir(this.xmlDirectory);
        const xmlFiles = files.filter(f => f.endsWith('.xml'));
        
        const laws: LawListItem[] = [];
        for (const file of xmlFiles) {
            const stat = await fs.stat(path.join(this.xmlDirectory, file));
            laws.push({
                lawId: this.extractLawId(file),
                lawTitle: await this.extractLawTitle(file),
                lastModified: stat.mtime.toISOString(),
                source: 'xml'
            });
        }
        
        // ページング処理
        const offset = options?.offset || 0;
        const limit = options?.limit || 1000;
        const paged = laws.slice(offset, offset + limit);
        
        return {
            laws: paged,
            hasMore: offset + limit < laws.length,
            nextOffset: offset + limit < laws.length ? offset + limit : undefined
        };
    }
    
    async fetchLawDetail(lawId: string): Promise<LawData> {
        const xmlPath = path.join(this.xmlDirectory, `${lawId}.xml`);
        const xmlData = await fs.readFile(xmlPath, 'utf-8');
        return this.parser.parseLaw(xmlData);
    }
    
    async fetchUpdatedLaws(since: Date): Promise<LawListResult> {
        // XMLファイルの場合は更新日時での差分取得は不可
        throw new Error('XML source does not support incremental updates');
    }
    
    private extractLawId(filename: string): string {
        return filename.replace('.xml', '');
    }
    
    private async extractLawTitle(filename: string): Promise<string> {
        // 簡易的にファイルの最初の部分から法令名を抽出
        const xmlPath = path.join(this.xmlDirectory, filename);
        const xmlData = await fs.readFile(xmlPath, 'utf-8');
        const match = xmlData.match(/<LawTitle[^>]*>([^<]+)<\/LawTitle>/);
        return match ? match[1] : filename;
    }
}
```

#### 5.1.3 APIデータソース

```typescript
// infrastructure/persistence/APIDataSource.ts
export class APIDataSource implements LawDataSource {
    readonly type = 'api' as const;
    
    constructor(
        private readonly apiClient: LawAPIClient,
        private readonly cache: CacheService
    ) {}
    
    async fetchLawList(options?: FetchOptions): Promise<LawListResult> {
        const cacheKey = `law-list-${JSON.stringify(options)}`;
        const cached = await this.cache.get<LawListResult>(cacheKey);
        if (cached) return cached;
        
        const result = await this.apiClient.getLaws({
            limit: options?.limit,
            offset: options?.offset,
            updatedSince: options?.updatedSince
        });
        
        const transformed: LawListResult = {
            laws: result.laws.map(law => ({
                lawId: law.law_id,
                lawTitle: law.title,
                lastModified: law.last_modified,
                source: 'api' as const
            })),
            hasMore: result.has_more,
            nextOffset: result.next_offset
        };
        
        await this.cache.set(cacheKey, transformed, 300); // 5分キャッシュ
        return transformed;
    }
    
    async fetchLawDetail(lawId: string): Promise<LawData> {
        const cacheKey = `law-detail-${lawId}`;
        const cached = await this.cache.get<LawData>(cacheKey);
        if (cached) return cached;
        
        const result = await this.apiClient.getLaw(lawId);
        const transformed = this.transformAPIResponse(result);
        
        await this.cache.set(cacheKey, transformed, 3600); // 1時間キャッシュ
        return transformed;
    }
    
    async fetchUpdatedLaws(since: Date): Promise<LawListResult> {
        return await this.fetchLawList({ updatedSince: since });
    }
    
    private transformAPIResponse(apiData: any): LawData {
        return {
            lawId: apiData.law_id,
            lawType: apiData.law_type,
            lawTitle: apiData.title,
            lawTitleKana: apiData.title_kana,
            promulgateDate: new Date(apiData.promulgate_date),
            enforceDate: apiData.enforce_date ? new Date(apiData.enforce_date) : null,
            articles: apiData.articles.map(this.transformArticle),
            source: 'api',
            lastModified: new Date(apiData.last_modified)
        };
    }
    
    private transformArticle(apiArticle: any): ArticleData {
        return {
            articleNum: apiArticle.number,
            articleTitle: apiArticle.title,
            paragraphs: apiArticle.paragraphs.map((p: any) => ({
                paragraphNum: p.number,
                content: p.content,
                items: p.items || []
            }))
        };
    }
}
```

#### 5.1.4 ハイブリッドデータソース

```typescript
// infrastructure/persistence/HybridDataSource.ts
export class HybridDataSource implements LawDataSource {
    readonly type = 'xml' as const; // デフォルトはXML優先
    
    constructor(
        private readonly xmlSource: LawDataSource,
        private readonly apiSource: LawDataSource,
        private readonly options: HybridSourceOptions
    ) {}
    
    async fetchLawList(options?: FetchOptions): Promise<LawListResult> {
        if (this.shouldUseAPI()) {
            try {
                return await this.apiSource.fetchLawList(options);
            } catch (error) {
                console.error('API source failed, falling back to XML', error);
                return await this.xmlSource.fetchLawList(options);
            }
        }
        return await this.xmlSource.fetchLawList(options);
    }
    
    async fetchLawDetail(lawId: string): Promise<LawData> {
        // まずAPIから取得を試みる（最新データ）
        try {
            const apiData = await this.apiSource.fetchLawDetail(lawId);
            return apiData;
        } catch (error) {
            // APIが失敗したらXMLにフォールバック
            console.warn(`API fetch failed for ${lawId}, using XML`, error);
            return await this.xmlSource.fetchLawDetail(lawId);
        }
    }
    
    async fetchUpdatedLaws(since: Date): Promise<LawListResult> {
        // 更新チェックは常にAPIを使用
        return await this.apiSource.fetchUpdatedLaws(since);
    }
    
    private shouldUseAPI(): boolean {
        // 初期化完了後はAPI優先
        return this.options.isInitialized || this.options.preferAPI;
    }
}

export interface HybridSourceOptions {
    isInitialized: boolean;
    preferAPI: boolean;
}
```

### 5.2 リポジトリ実装

#### 5.2.1 PostgreSQL法令リポジトリ

```typescript
// infrastructure/persistence/PostgresLawRepository.ts
export class PostgresLawRepository implements LawRepository {
    constructor(
        private readonly prisma: PrismaClient,
        private readonly mapper: LawMapper,
        private readonly dataSource?: LawDataSource
    ) {}

    async findById(id: LawId): Promise<Law | null> {
        const data = await this.prisma.law.findUnique({
            where: { lawId: id.value },
            include: {
                articles: {
                    include: {
                        paragraphs: {
                            include: {
                                items: true
                            }
                        }
                    }
                }
            }
        });

        if (!data) return null;

        return this.mapper.toDomain(data);
    }

    async save(law: Law): Promise<void> {
        const data = this.mapper.toPersistence(law);

        await this.prisma.law.upsert({
            where: { lawId: data.lawId },
            create: data,
            update: {
                ...data,
                updatedAt: new Date()
            }
        });
    }

    async findByType(type: LawType, options?: FindOptions): Promise<Law[]> {
        const limit = options?.limit || 100;
        const offset = options?.offset || 0;

        const data = await this.prisma.law.findMany({
            where: { lawType: type },
            skip: offset,
            take: limit,
            orderBy: { promulgateDate: 'desc' }
        });

        return data.map(d => this.mapper.toDomain(d));
    }
}
```

#### 5.2.2 Neo4j参照リポジトリ

```typescript
// infrastructure/persistence/Neo4jReferenceRepository.ts
export class Neo4jReferenceRepository implements ReferenceRepository {
    constructor(
        private readonly driver: Driver,
        private readonly mapper: ReferenceMapper
    ) {}

    async findById(id: ReferenceId): Promise<Reference | null> {
        const session = this.driver.session();
        
        try {
            const result = await session.run(
                `MATCH (source)-[ref:REFERENCES {reference_id: $id}]->(target)
                 RETURN source, ref, target`,
                { id: id.value }
            );

            if (result.records.length === 0) return null;

            const record = result.records[0];
            return this.mapper.toDomain(
                record.get('source'),
                record.get('ref'),
                record.get('target')
            );
        } finally {
            await session.close();
        }
    }

    async save(reference: Reference): Promise<void> {
        const session = this.driver.session();
        
        try {
            const data = this.mapper.toPersistence(reference);
            
            await session.run(
                `MATCH (source {${data.source.type}_id: $sourceId})
                 MATCH (target {${data.target.type}_id: $targetId})
                 MERGE (source)-[ref:REFERENCES {reference_id: $refId}]->(target)
                 SET ref += $properties`,
                {
                    sourceId: data.source.id,
                    targetId: data.target.id,
                    refId: data.referenceId,
                    properties: data.properties
                }
            );
        } finally {
            await session.close();
        }
    }

    async findOutgoing(nodeId: string, options?: ReferenceQueryOptions): Promise<Reference[]> {
        const session = this.driver.session();
        
        try {
            const whereClause = this.buildWhereClause(options);
            const result = await session.run(
                `MATCH (source {article_id: $nodeId})-[ref:REFERENCES]->(target)
                 ${whereClause}
                 RETURN source, ref, target
                 ORDER BY ref.confidence DESC
                 LIMIT $limit`,
                {
                    nodeId,
                    minConfidence: options?.minConfidence || 0,
                    limit: options?.limit || 100
                }
            );

            return result.records.map(record => 
                this.mapper.toDomain(
                    record.get('source'),
                    record.get('ref'),
                    record.get('target')
                )
            );
        } finally {
            await session.close();
        }
    }

    private buildWhereClause(options?: ReferenceQueryOptions): string {
        const conditions: string[] = [];
        
        if (options?.minConfidence) {
            conditions.push('ref.ai_analysis.confidence >= $minConfidence');
        }
        
        if (options?.referenceTypes && options.referenceTypes.length > 0) {
            conditions.push(`ref.primary_type IN [${options.referenceTypes.map(t => `'${t}'`).join(',')}]`);
        }
        
        if (options?.verifiedOnly) {
            conditions.push('ref.human_verified = true');
        }
        
        return conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';
    }
}
```

### 5.3 外部サービス連携

#### 5.3.1 AI参照解決サービス

```typescript
// infrastructure/external/AIReferenceResolver.ts
export class AIReferenceResolver {
    constructor(
        private readonly llmClient: LLMClient,
        private readonly cache: CacheService
    ) {}

    async resolve(
        pattern: MatchedPattern,
        context: ResolutionContext
    ): Promise<ResolvedReference> {
        // キャッシュチェック
        const cacheKey = this.generateCacheKey(pattern, context);
        const cached = await this.cache.get(cacheKey);
        
        if (cached) {
            return cached;
        }

        // プロンプト生成
        const prompt = this.buildPrompt(pattern, context);
        
        // LLM呼び出し
        const response = await this.llmClient.generate({
            model: 'llama3-elyza-jp-8b',
            prompt: prompt,
            temperature: 0.1,
            maxTokens: 500,
            responseFormat: 'json'
        });

        // レスポンス解析
        const parsed = this.parseResponse(response);
        const resolved = this.buildResolvedReference(pattern, parsed);

        // キャッシュ保存
        await this.cache.set(cacheKey, resolved, 3600); // 1時間

        return resolved;
    }

    private buildPrompt(pattern: MatchedPattern, context: ResolutionContext): string {
        return `
法令の参照関係を解決してください。

現在の法令: ${context.currentLaw.title}
現在の条文: 第${context.currentArticle.number}条
参照テキスト: ${pattern.text}
前後の文脈: ${context.surroundingText}

以下の形式でJSONを返してください：
{
    "targetLaw": {
        "title": "参照先の法令名",
        "id": "参照先の法令ID（分かる場合）"
    },
    "targetArticle": {
        "number": 参照先の条番号,
        "paragraph": 参照先の項番号（該当する場合）
    },
    "confidence": 0.0-1.0,
    "reasoning": "判断の根拠"
}`;
    }
}
```

#### 5.3.2 法令APIクライアント

```typescript
// infrastructure/external/LawAPIClient.ts
import Bottleneck from 'bottleneck';
import axios, { AxiosInstance } from 'axios';

export class LawAPIClient {
    private axios: AxiosInstance;
    private rateLimiter: Bottleneck;
    
    constructor(private readonly config: APIConfig) {
        this.axios = axios.create({
            baseURL: config.baseUrl,
            timeout: config.timeout || 30000,
            headers: {
                'Authorization': `Bearer ${config.apiKey}`,
                'Accept': 'application/json',
                'Content-Type': 'application/json'
            }
        });
        
        // レート制限: 1000リクエスト/時間
        this.rateLimiter = new Bottleneck({
            minTime: 3600, // 3.6秒に1リクエスト
            maxConcurrent: 5,
            reservoir: 1000,
            reservoirRefreshAmount: 1000,
            reservoirRefreshInterval: 60 * 60 * 1000 // 1時間
        });
        
        // リトライ設定
        this.setupRetry();
    }
    
    async getLaws(options?: GetLawsOptions): Promise<GetLawsResponse> {
        return this.rateLimiter.schedule(async () => {
            const response = await this.axios.get('/laws', {
                params: {
                    limit: options?.limit || 100,
                    offset: options?.offset || 0,
                    updated_since: options?.updatedSince?.toISOString()
                }
            });
            return response.data;
        });
    }
    
    async getLaw(lawId: string): Promise<GetLawResponse> {
        return this.rateLimiter.schedule(async () => {
            const response = await this.axios.get(`/laws/${lawId}`);
            return response.data;
        });
    }
    
    async getRateLimitStatus(): Promise<RateLimitStatus> {
        const response = await this.axios.get('/rate-limit');
        return {
            limit: parseInt(response.headers['x-ratelimit-limit'] || '1000'),
            remaining: parseInt(response.headers['x-ratelimit-remaining'] || '0'),
            resetAt: new Date(parseInt(response.headers['x-ratelimit-reset'] || '0') * 1000)
        };
    }
    
    private setupRetry(): void {
        this.axios.interceptors.response.use(
            response => response,
            async error => {
                if (error.response?.status === 429) {
                    // レート制限エラー
                    const retryAfter = error.response.headers['retry-after'] || 60;
                    await this.delay(retryAfter * 1000);
                    return this.axios.request(error.config);
                }
                
                if (error.response?.status >= 500) {
                    // サーバーエラー時のリトライ
                    const retries = error.config.__retryCount || 0;
                    if (retries < 3) {
                        error.config.__retryCount = retries + 1;
                        await this.delay(Math.pow(2, retries) * 1000);
                        return this.axios.request(error.config);
                    }
                }
                
                return Promise.reject(error);
            }
        );
    }
    
    private delay(ms: number): Promise<void> {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

export interface APIConfig {
    baseUrl: string;
    apiKey: string;
    timeout?: number;
}

export interface GetLawsOptions {
    limit?: number;
    offset?: number;
    updatedSince?: Date;
}

export interface GetLawsResponse {
    laws: Array<{
        law_id: string;
        title: string;
        law_type: string;
        last_modified: string;
    }>;
    has_more: boolean;
    next_offset?: number;
}

export interface GetLawResponse {
    law_id: string;
    law_type: string;
    title: string;
    title_kana: string;
    promulgate_date: string;
    enforce_date?: string;
    articles: Array<{
        number: number;
        title?: string;
        paragraphs: Array<{
            number: number;
            content: string;
            items?: string[];
        }>;
    }>;
    last_modified: string;
}

export interface RateLimitStatus {
    limit: number;
    remaining: number;
    resetAt: Date;
}
```

### 5.4 設定管理

```typescript
// infrastructure/config/Configuration.ts
export class Configuration {
    private static instance: Configuration;
    
    private constructor(
        private readonly env: NodeJS.ProcessEnv
    ) {}

    static getInstance(): Configuration {
        if (!Configuration.instance) {
            Configuration.instance = new Configuration(process.env);
        }
        return Configuration.instance;
    }

    get database() {
        return {
            postgres: {
                url: this.env.DATABASE_URL || 'postgresql://localhost:5432/lawfinder',
                poolSize: parseInt(this.env.DB_POOL_SIZE || '10')
            },
            neo4j: {
                uri: this.env.NEO4J_URI || 'bolt://localhost:7687',
                user: this.env.NEO4J_USER || 'neo4j',
                password: this.env.NEO4J_PASSWORD || 'password'
            },
            redis: {
                url: this.env.REDIS_URL || 'redis://localhost:6379'
            },
            elasticsearch: {
                node: this.env.ELASTICSEARCH_URL || 'http://localhost:9200'
            }
        };
    }
    
    get api() {
        return {
            baseUrl: this.env.LAW_API_BASE_URL || 'https://api.e-gov.go.jp/laws/v1',
            apiKey: this.env.LAW_API_KEY || '',
            timeout: parseInt(this.env.LAW_API_TIMEOUT || '30000')
        };
    }
    
    get dataPath() {
        return {
            xmlDirectory: this.env.XML_DATA_PATH || './laws_data',
            cacheDirectory: this.env.CACHE_DATA_PATH || './cache'
        };
    }

    get llm() {
        return {
            model: this.env.LLM_MODEL || 'llama3-elyza-jp-8b',
            endpoint: this.env.LLM_ENDPOINT || 'http://localhost:11434',
            timeout: parseInt(this.env.LLM_TIMEOUT || '30000')
        };
    }

    get app() {
        return {
            port: parseInt(this.env.PORT || '3000'),
            env: this.env.NODE_ENV || 'development',
            logLevel: this.env.LOG_LEVEL || 'info'
        };
    }
}
```

## 6. プレゼンテーション層設計

### 6.1 コントローラー

```typescript
// presentation/controllers/LawController.ts
@Controller('/api/v1/laws')
export class LawController {
    constructor(
        private readonly searchLawsUseCase: SearchLawsUseCase,
        private readonly getLawDetailUseCase: GetLawDetailUseCase
    ) {}

    @Get('/')
    async searchLaws(
        @Query() query: SearchLawsRequest,
        @Res() res: Response
    ): Promise<void> {
        try {
            const result = await this.searchLawsUseCase.execute({
                keyword: query.q,
                lawType: query.law_type,
                status: query.status,
                dateRange: {
                    from: query.promulgate_date_from,
                    to: query.promulgate_date_to
                },
                page: query.page,
                limit: query.limit
            });

            res.json({
                data: result.laws,
                pagination: {
                    page: query.page || 1,
                    limit: query.limit || 20,
                    total_items: result.totalCount,
                    total_pages: Math.ceil(result.totalCount / (query.limit || 20))
                }
            });
        } catch (error) {
            this.handleError(error, res);
        }
    }

    @Get('/:law_id')
    async getLawDetail(
        @Param('law_id') lawId: string,
        @Query('include') include: string[],
        @Res() res: Response
    ): Promise<void> {
        try {
            const result = await this.getLawDetailUseCase.execute({
                lawId,
                includeArticles: include?.includes('articles'),
                includeReferences: include?.includes('references')
            });

            res.json(result);
        } catch (error) {
            this.handleError(error, res);
        }
    }

    private handleError(error: Error, res: Response): void {
        if (error instanceof NotFoundError) {
            res.status(404).json({
                code: 'NOT_FOUND',
                message: error.message
            });
        } else if (error instanceof ValidationError) {
            res.status(400).json({
                code: 'VALIDATION_ERROR',
                message: error.message,
                details: error.details
            });
        } else {
            res.status(500).json({
                code: 'INTERNAL_ERROR',
                message: 'サーバーエラーが発生しました'
            });
        }
    }
}
```

### 6.2 ミドルウェア

```typescript
// presentation/middlewares/AuthenticationMiddleware.ts
export class AuthenticationMiddleware {
    constructor(
        private readonly jwtService: JWTService,
        private readonly userRepository: UserRepository
    ) {}

    async authenticate(req: Request, res: Response, next: NextFunction): Promise<void> {
        try {
            const token = this.extractToken(req);
            if (!token) {
                return this.unauthorized(res);
            }

            const payload = await this.jwtService.verify(token);
            const user = await this.userRepository.findById(payload.userId);
            
            if (!user || !user.isActive) {
                return this.unauthorized(res);
            }

            req.user = user;
            next();
        } catch (error) {
            this.unauthorized(res);
        }
    }

    private extractToken(req: Request): string | null {
        const authHeader = req.headers.authorization;
        if (!authHeader || !authHeader.startsWith('Bearer ')) {
            return null;
        }
        return authHeader.substring(7);
    }

    private unauthorized(res: Response): void {
        res.status(401).json({
            code: 'UNAUTHORIZED',
            message: '認証が必要です'
        });
    }
}
```

## 7. 依存性注入設定

```typescript
// container.ts (Phase 2でInversifyJS使用)
import { Container } from 'inversify';

const container = new Container();

// データソース
container.bind<DataSourceFactory>(TYPES.DataSourceFactory)
    .to(DataSourceFactory)
    .inSingletonScope();

container.bind<LawDataSource>(TYPES.LawDataSource)
    .toDynamicValue((context) => {
        const factory = context.container.get<DataSourceFactory>(TYPES.DataSourceFactory);
        const config = context.container.get<Configuration>(TYPES.Configuration);
        
        // 初期化状態に応じてデータソースを切り替え
        if (config.app.isInitialized) {
            return factory.createAPISource();
        } else {
            return factory.createHybridSource({
                isInitialized: false,
                preferAPI: false
            });
        }
    })
    .inRequestScope();

// リポジトリ
container.bind<LawRepository>(TYPES.LawRepository)
    .to(PostgresLawRepository)
    .inSingletonScope();

container.bind<ReferenceRepository>(TYPES.ReferenceRepository)
    .to(Neo4jReferenceRepository)
    .inSingletonScope();

// ドメインサービス
container.bind<ReferenceAnalysisService>(TYPES.ReferenceAnalysisService)
    .to(ReferenceAnalysisService)
    .inRequestScope();

// ユースケース
container.bind<SearchLawsUseCase>(TYPES.SearchLawsUseCase)
    .to(SearchLawsUseCase)
    .inRequestScope();

// 外部サービス
container.bind<LLMClient>(TYPES.LLMClient)
    .to(OllamaClient)
    .inSingletonScope();

container.bind<LawAPIClient>(TYPES.LawAPIClient)
    .toDynamicValue((context) => {
        const config = context.container.get<Configuration>(TYPES.Configuration);
        return new LawAPIClient(config.api);
    })
    .inSingletonScope();

container.bind<CacheService>(TYPES.CacheService)
    .to(RedisCacheService)
    .inSingletonScope();

export { container };
```

## 8. エラーハンドリング

```typescript
// shared/errors/DomainError.ts
export abstract class DomainError extends Error {
    constructor(message: string) {
        super(message);
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
    }
}

export class InvalidLawIdError extends DomainError {
    constructor(value: string) {
        super(`不正な法令IDです: ${value}`);
    }
}

export class NotFoundError extends DomainError {
    constructor(resource: string, id: string) {
        super(`${resource}が見つかりません: ${id}`);
    }
}

export class ValidationError extends DomainError {
    constructor(
        message: string,
        public readonly details?: Record<string, any>
    ) {
        super(message);
    }
}

// エラーハンドラー
export class ErrorHandler {
    static handle(error: Error): ErrorResponse {
        if (error instanceof ValidationError) {
            return {
                code: 'VALIDATION_ERROR',
                message: error.message,
                details: error.details,
                statusCode: 400
            };
        }
        
        if (error instanceof NotFoundError) {
            return {
                code: 'NOT_FOUND',
                message: error.message,
                statusCode: 404
            };
        }
        
        // その他のエラー
        console.error('Unhandled error:', error);
        return {
            code: 'INTERNAL_ERROR',
            message: 'サーバーエラーが発生しました',
            statusCode: 500
        };
    }
}
```

## 9. テスト設計

### 9.1 ユニットテスト例

```typescript
// tests/domain/models/Law.test.ts
describe('Law', () => {
    describe('create', () => {
        it('should create a new law with valid parameters', () => {
            const params = {
                type: LawType.Act,
                year: 2025,
                number: 89,
                title: '民法',
                titleKana: 'みんぽう',
                promulgateDate: new Date('2025-04-27')
            };

            const law = Law.create(params);

            expect(law.lawId).toBe('025AC0000000089');
            expect(law.lawTitle).toBe('民法');
            expect(law.status).toBe(LawStatus.NotYetEnforced);
        });

        it('should throw error with invalid title', () => {
            const params = {
                type: LawType.Act,
                year: 2025,
                number: 89,
                title: '', // 空のタイトル
                promulgateDate: new Date('2025-04-27')
            };

            expect(() => Law.create(params)).toThrow(InvalidLawTitleError);
        });
    });

    describe('enforce', () => {
        it('should enforce law with valid date', () => {
            const law = createTestLaw();
            const enforceDate = new Date('2025-06-01');

            law.enforce(enforceDate);

            expect(law.status).toBe(LawStatus.Active);
            expect(law.enforceDate).toEqual(enforceDate);
        });
    });
});
```

### 9.2 統合テスト例

```typescript
// tests/integration/ReferenceAnalysis.test.ts
describe('Reference Analysis Integration', () => {
    let referenceAnalysisService: ReferenceAnalysisService;
    let referenceRepository: ReferenceRepository;

    beforeEach(async () => {
        // テスト用のコンテナ設定
        const container = createTestContainer();
        referenceAnalysisService = container.get(TYPES.ReferenceAnalysisService);
        referenceRepository = container.get(TYPES.ReferenceRepository);
    });

    it('should extract and save references from article', async () => {
        const article = createTestArticle({
            content: '第三条の規定により、民法第九十四条第二項の規定を準用する。'
        });

        const references = await referenceAnalysisService.analyzeArticle(article);

        expect(references).toHaveLength(2);
        expect(references[0].type).toBe(ReferenceType.FOLLOW);
        expect(references[1].type).toBe(ReferenceType.APPLY);

        // リポジトリに保存されていることを確認
        const saved = await referenceRepository.findOutgoing(article.id);
        expect(saved).toHaveLength(2);
    });
});
```

## 10. 改訂履歴

| バージョン | 日付 | 変更内容 |
|----------|------|----------|
| 1.0 | 2025-08-03 | 初版作成 |
| 1.1 | 2025-08-03 | データソース抽象化追加：リポジトリインターフェース定義、XMLファイル/API対応データソース実装、法令APIクライアント追加 |
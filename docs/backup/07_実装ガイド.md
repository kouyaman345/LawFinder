# 07_実装ガイド

**作成日**: 2025年8月21日  
**対象プロジェクト**: LawFinder  
**ステータス**: Phase 2実装中  

## 1. 実装概要

### 1.1 プロジェクト概要

LawFinderは日本の法的文書検索・法改正支援アプリケーションです。政府標準XMLファイルを処理し、法的構造の可視化、法律間の相互参照の検出、改正影響分析を目的としています。

### 1.2 開発方針

```typescript
// DDD（ドメイン駆動設計）とClean Architectureに基づく実装
// 段階的な機能拡張（Phase 1 → Phase 2）
// TypeScript + Next.js 15による型安全な開発
```

## 2. 開発環境とセットアップ

### 2.1 必要なツール

| ツール | バージョン | 用途 |
|--------|-----------|------|
| Node.js | 18.x以上 | JavaScript実行環境 |
| npm | 8.x以上 | パッケージ管理 |
| TypeScript | 5.3.3 | 静的型付け |
| Next.js | 15.4.5 | フルスタックフレームワーク |
| Prisma | 5.20.0 | ORM |
| Docker | latest | データベースコンテナ |

### 2.2 環境構築手順

```bash
# 1. リポジトリクローン
git clone <repository-url>
cd LawFinder

# 2. 依存関係のインストール
npm install

# 3. データベース起動（PostgreSQL + Neo4j）
docker-compose up -d postgres
docker-compose -f docker-compose.neo4j.yml up -d

# 4. データベース初期化
npx prisma migrate dev
npx prisma generate

# 5. 環境変数設定
cp .env.example .env.local
# DATABASE_URL, NEO4J_URI, NEO4J_USERNAMEなどを設定

# 6. 開発サーバー起動
npm run dev  # http://localhost:3000
```

### 2.3 LLM統合環境（オプション）

```bash
# Ollama起動（ローカルLLM使用時）
./scripts/startup.sh

# モデル確認
curl http://localhost:11434/api/tags
```

## 3. プロジェクト構造

### 3.1 ディレクトリ構成

```
LawFinder/
├── app/                     # Next.js App Router
│   ├── api/                # API Routes
│   ├── laws/               # 法令詳細ページ
│   └── globals.css         # グローバルスタイル
├── src/                    # ビジネスロジック
│   ├── domain/             # ドメインモデル
│   ├── infrastructure/     # インフラ層
│   └── lib/               # ユーティリティ
├── prisma/                 # Prisma ORM
│   ├── schema.prisma      # データベーススキーマ
│   └── migrations/        # マイグレーションファイル
├── scripts/                # 開発・運用スクリプト
│   ├── cli.ts             # 統合CLIツール
│   ├── detector.ts        # 参照検出エンジン
│   └── manager.ts         # 参照管理システム
├── docs/                   # 設計書・ドキュメント
├── laws_data/             # 法令XMLデータ
└── Report/                # 分析レポート
```

### 3.2 アーキテクチャレイヤー

```typescript
// Clean Architecture
interface LayeredArchitecture {
  presentation: 'Next.js Pages/Components';
  application: 'Use Cases/Services';
  domain: 'Entities/Value Objects';
  infrastructure: 'Repositories/External APIs';
}
```

## 4. 実装パターンとコーディング規約

### 4.1 TypeScript実装パターン

#### ドメインモデルの実装

```typescript
// 値オブジェクト（Value Object）
export class LawId {
  constructor(private readonly value: string) {
    if (!this.isValid(value)) {
      throw new Error('Invalid LawId format');
    }
  }

  private isValid(value: string): boolean {
    return /^\d{3}[A-Z]{2}\d{10}$/.test(value);
  }

  toString(): string {
    return this.value;
  }
}

// エンティティ（Entity）
export class Law {
  private constructor(
    private readonly lawId: LawId,
    private readonly lawInfo: LawInfo,
    private articles: Article[]
  ) {}

  static create(lawId: string, lawInfo: LawInfo): Law {
    return new Law(new LawId(lawId), lawInfo, []);
  }

  addArticle(article: Article): void {
    this.articles.push(article);
  }
}
```

#### サービスクラスの実装

```typescript
// アプリケーションサービス
export class ReferenceDetectionService {
  constructor(
    private detector: UltimateReferenceDetector,
    private aiResolver: AIReferenceResolver,
    private repository: ReferenceRepository
  ) {}

  async detectAndSaveReferences(lawId: string): Promise<void> {
    try {
      // 1. 参照検出実行
      const references = await this.detector.detect(lawId);
      
      // 2. AI分析による精度向上
      const enhancedRefs = await this.aiResolver.enhance(references);
      
      // 3. 永続化
      await this.repository.save(enhancedRefs);
    } catch (error) {
      Logger.error('Reference detection failed', { lawId, error });
      throw error;
    }
  }
}
```

### 4.2 エラーハンドリング

```typescript
// カスタムエラークラス
export class LawFinderError extends Error {
  constructor(
    message: string,
    public readonly code: ErrorCode,
    public readonly details?: Record<string, any>
  ) {
    super(message);
    this.name = 'LawFinderError';
  }
}

// エラーハンドリングミドルウェア
export function withErrorHandler<T extends any[], R>(
  fn: (...args: T) => Promise<R>
) {
  return async (...args: T): Promise<R> => {
    try {
      return await fn(...args);
    } catch (error) {
      Logger.error('Operation failed', { args, error });
      throw error;
    }
  };
}
```

### 4.3 型定義とインターフェース

```typescript
// 基本的な型定義
export interface Reference {
  referenceId: string;
  sourceArticleId: string;
  targetArticleId: string;
  referenceText: string;
  referenceType: ReferenceType;
  confidence: number;
  detectionMethod: 'pattern' | 'llm' | 'combined';
  createdAt: Date;
  updatedAt: Date;
}

// ジェネリック型の活用
export interface Repository<T, ID> {
  findById(id: ID): Promise<T | null>;
  save(entity: T): Promise<void>;
  delete(id: ID): Promise<void>;
}

export interface LawRepository extends Repository<Law, LawId> {
  findByTitle(title: string): Promise<Law[]>;
  findByLawNumber(lawNumber: string): Promise<Law | null>;
}
```

## 5. データベース操作

### 5.1 Prisma ORM の使用

```typescript
// Prisma Client の初期化
const prisma = new PrismaClient({
  log: ['query', 'info', 'warn', 'error'],
});

// 基本的なCRUD操作
export class PrismaLawRepository implements LawRepository {
  async findById(lawId: LawId): Promise<Law | null> {
    const lawData = await prisma.law.findUnique({
      where: { lawId: lawId.toString() },
      include: {
        articles: {
          include: {
            paragraphs: {
              include: {
                items: true
              }
            }
          }
        }
      }
    });

    return lawData ? this.toDomain(lawData) : null;
  }

  private toDomain(data: any): Law {
    // ORM → ドメインモデル変換
    return Law.create(data.lawId, new LawInfo(data.lawTitle, data.lawNum));
  }
}
```

### 5.2 Neo4j統合（ハイブリッドDB）

```typescript
// HybridDBClient の使用
export class HybridReferenceService {
  constructor(
    private hybridDB: HybridDBClient
  ) {}

  async getReferencesForLaw(lawId: string): Promise<Reference[]> {
    // Neo4jから参照関係を取得
    return await this.hybridDB.getReferences(lawId);
  }

  async analyzeImpact(lawId: string, articleIds: string[]): Promise<ImpactAnalysisResult> {
    // Neo4jのグラフ探索機能を活用
    const cypher = `
      MATCH path = (source:Article)
        <-[:REFERS_TO*1..5]-(affected:Article)
      WHERE source.article_id IN $articleIds
      RETURN affected, length(path) as distance
    `;
    
    return await this.hybridDB.runCypher(cypher, { articleIds });
  }
}
```

## 6. API実装

### 6.1 Next.js API Routes

```typescript
// app/api/laws/[id]/route.ts
export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const lawService = new LawService();
    const law = await lawService.getLawById(params.id);
    
    if (!law) {
      return NextResponse.json(
        { error: 'Law not found' },
        { status: 404 }
      );
    }
    
    return NextResponse.json(law);
  } catch (error) {
    Logger.error('API error', { lawId: params.id, error });
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

### 6.2 認証・認可

```typescript
// JWT認証ミドルウェア
export function withAuth(handler: NextApiHandler) {
  return async (req: NextApiRequest, res: NextApiResponse) => {
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({ error: 'Unauthorized' });
    }
    
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET!);
      req.user = decoded;
      return handler(req, res);
    } catch (error) {
      return res.status(401).json({ error: 'Invalid token' });
    }
  };
}
```

## 7. フロントエンド実装

### 7.1 React Componentsの実装

```typescript
// 法令詳細コンポーネント
export default function LawDetail({ law }: { law: Law }) {
  const [selectedArticle, setSelectedArticle] = useState<string | null>(null);
  const [references, setReferences] = useState<Reference[]>([]);

  useEffect(() => {
    // 参照関係の読み込み
    fetchReferences(law.lawId).then(setReferences);
  }, [law.lawId]);

  return (
    <div className="flex h-screen">
      <LawNavigation 
        law={law} 
        onArticleSelect={setSelectedArticle}
      />
      <LawContent 
        law={law} 
        selectedArticle={selectedArticle}
        references={references}
      />
    </div>
  );
}
```

### 7.2 状態管理

```typescript
// カスタムフック
export function useLawData(lawId: string) {
  const [law, setLaw] = useState<Law | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchLaw = async () => {
      try {
        setLoading(true);
        const response = await fetch(`/api/laws/${lawId}`);
        if (!response.ok) {
          throw new Error('Failed to fetch law');
        }
        const lawData = await response.json();
        setLaw(lawData);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error');
      } finally {
        setLoading(false);
      }
    };

    fetchLaw();
  }, [lawId]);

  return { law, loading, error };
}
```

## 8. 参照検出エンジンの実装

### 8.1 UltimateReferenceDetector

```typescript
export class UltimateReferenceDetector {
  private readonly patterns = [
    // 基本的な条文参照
    {
      pattern: /第([０-９0-9一二三四五六七八九十百千]+)条/g,
      type: ReferenceType.INTERNAL_REFERENCE
    },
    // 外部法令参照
    {
      pattern: /(民法|刑法|商法|会社法).*?第([０-９0-9一二三四五六七八九十百千]+)条/g,
      type: ReferenceType.EXTERNAL_REFERENCE
    },
    // 相対参照
    {
      pattern: /(前|次|同)(項|条|号)/g,
      type: ReferenceType.RELATIVE_REFERENCE
    }
  ];

  async detect(text: string, context: DetectionContext): Promise<Reference[]> {
    const references: Reference[] = [];
    
    for (const patternDef of this.patterns) {
      const matches = Array.from(text.matchAll(patternDef.pattern));
      
      for (const match of matches) {
        const reference = await this.createReference(
          match, 
          patternDef.type, 
          context
        );
        references.push(reference);
      }
    }
    
    return references;
  }

  private async createReference(
    match: RegExpMatchArray,
    type: ReferenceType,
    context: DetectionContext
  ): Promise<Reference> {
    return {
      referenceId: generateId(),
      sourceArticleId: context.sourceArticleId,
      targetArticleId: await this.resolveTarget(match, context),
      referenceText: match[0],
      referenceType: type,
      confidence: 0.9,
      detectionMethod: 'pattern',
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }
}
```

### 8.2 統合CLIツールの使用

```bash
# 統合CLIによる参照管理
npx tsx scripts/cli.ts ref detect "民法第90条"        # 参照検出
npx tsx scripts/cli.ts ref process 129AC0000000089   # 法令処理
npx tsx scripts/cli.ts law import --major           # 法令インポート
npx tsx scripts/cli.ts test validate -n 1000        # 大規模検証
npx tsx scripts/cli.ts sync neo4j --force           # Neo4j同期
npx tsx scripts/cli.ts interactive                  # インタラクティブモード
```

## 9. テスト実装

### 9.1 単体テスト（Jest）

```typescript
// 参照検出器のテスト
describe('UltimateReferenceDetector', () => {
  let detector: UltimateReferenceDetector;

  beforeEach(() => {
    detector = new UltimateReferenceDetector();
  });

  it('should detect internal references', async () => {
    const text = '第90条の規定により無効とする。';
    const context = {
      sourceArticleId: 'test-article-1',
      lawId: 'test-law-1'
    };

    const references = await detector.detect(text, context);

    expect(references).toHaveLength(1);
    expect(references[0].referenceType).toBe(ReferenceType.INTERNAL_REFERENCE);
    expect(references[0].referenceText).toBe('第90条');
  });

  it('should detect external references', async () => {
    const text = '民法第90条の規定により無効とする。';
    const context = {
      sourceArticleId: 'test-article-1',
      lawId: 'test-law-1'
    };

    const references = await detector.detect(text, context);

    expect(references).toHaveLength(1);
    expect(references[0].referenceType).toBe(ReferenceType.EXTERNAL_REFERENCE);
  });
});
```

### 9.2 統合テスト

```typescript
// API統合テスト
describe('Laws API', () => {
  it('should return law data', async () => {
    const response = await request(app)
      .get('/api/laws/129AC0000000089')
      .expect(200);

    expect(response.body).toHaveProperty('lawId');
    expect(response.body).toHaveProperty('lawTitle');
    expect(response.body.lawTitle).toBe('民法');
  });

  it('should return references for law', async () => {
    const response = await request(app)
      .get('/api/laws/129AC0000000089/references')
      .expect(200);

    expect(Array.isArray(response.body)).toBe(true);
    expect(response.body.length).toBeGreaterThan(0);
  });
});
```

## 10. デプロイメントとCI/CD

### 10.1 GitHub Actions

```yaml
# .github/workflows/deploy.yml
name: Deploy
on:
  push:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - run: npm ci
      - run: npm run typecheck
      - run: npm test
      - run: npm run build

  deploy:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to production
        run: |
          # デプロイスクリプト実行
          npm run deploy:prod
```

### 10.2 環境設定

```bash
# 本番環境変数の設定例
DATABASE_URL="postgresql://user:pass@localhost:5432/lawfinder_prod"
NEO4J_URI="bolt://localhost:7687"
NEO4J_USERNAME="neo4j"
NEO4J_PASSWORD="password"
JWT_SECRET="your-super-secret-key"
OPENAI_API_KEY="sk-..."
OLLAMA_BASE_URL="http://localhost:11434"
```

## 11. パフォーマンス最適化

### 11.1 データベース最適化

```sql
-- PostgreSQL最適化インデックス
CREATE INDEX idx_articles_law_id ON articles(law_id);
CREATE INDEX idx_references_source ON references(source_article_id);
CREATE INDEX idx_references_target ON references(target_article_id);
CREATE INDEX idx_law_title_gin ON laws USING gin(to_tsvector('japanese', law_title));
```

### 11.2 キャッシュ戦略

```typescript
// Redis キャッシュ実装
export class CacheService {
  private redis: Redis;

  async getCachedLaw(lawId: string): Promise<Law | null> {
    const cached = await this.redis.get(`law:${lawId}`);
    return cached ? JSON.parse(cached) : null;
  }

  async setCachedLaw(lawId: string, law: Law): Promise<void> {
    await this.redis.setex(
      `law:${lawId}`, 
      3600, // 1時間
      JSON.stringify(law)
    );
  }
}
```

### 11.3 フロントエンド最適化

```typescript
// 動的インポートによるコード分割
const LawVisualization = lazy(() => import('./LawVisualization'));

// メモ化による再レンダリング防止
const MemoizedLawContent = memo(LawContent);

// Virtual scrolling for large lists
const VirtualizedArticleList = ({ articles }: { articles: Article[] }) => {
  return (
    <FixedSizeList
      height={600}
      itemCount={articles.length}
      itemSize={50}
    >
      {({ index, style }) => (
        <div style={style}>
          <ArticleItem article={articles[index]} />
        </div>
      )}
    </FixedSizeList>
  );
};
```

## 12. 運用とメンテナンス

### 12.1 ログ管理

```typescript
// 構造化ログ実装
export class Logger {
  static info(message: string, meta?: Record<string, any>): void {
    console.log(JSON.stringify({
      level: 'info',
      timestamp: new Date().toISOString(),
      message,
      meta
    }));
  }

  static error(message: string, error: Error, meta?: Record<string, any>): void {
    console.error(JSON.stringify({
      level: 'error',
      timestamp: new Date().toISOString(),
      message,
      error: {
        name: error.name,
        message: error.message,
        stack: error.stack
      },
      meta
    }));
  }
}
```

### 12.2 ヘルスチェック

```typescript
// app/api/health/route.ts
export async function GET() {
  try {
    // データベース接続確認
    await prisma.$queryRaw`SELECT 1`;
    
    // Neo4j接続確認
    await hybridDB.testConnection();
    
    return NextResponse.json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      services: {
        database: 'up',
        neo4j: 'up'
      }
    });
  } catch (error) {
    return NextResponse.json(
      {
        status: 'unhealthy',
        error: error.message
      },
      { status: 503 }
    );
  }
}
```

### 12.3 データ移行とバックアップ

```bash
# データベースマイグレーション
npx prisma migrate deploy

# データバックアップ
pg_dump lawfinder_prod > backup_$(date +%Y%m%d).sql

# Neo4jデータエクスポート
npx tsx scripts/cli.ts export neo4j --output backup/
```

## 13. トラブルシューティング

### 13.1 よくある問題と解決方法

| 問題 | 原因 | 解決方法 |
|------|------|----------|
| 参照検出が動作しない | パターンマッチングの不具合 | `scripts/detector.ts`のパターンを確認 |
| Neo4j接続エラー | 認証情報の不一致 | `.env`ファイルの設定を確認 |
| ビルドエラー | TypeScript型エラー | `npm run typecheck`で詳細確認 |
| パフォーマンス低下 | インデックス不足 | データベースインデックスを追加 |

### 13.2 デバッグ手法

```typescript
// デバッグログの有効化
if (process.env.NODE_ENV === 'development') {
  Logger.debug('Reference detection started', { lawId, context });
}

// パフォーマンス測定
const startTime = performance.now();
const result = await heavyOperation();
const endTime = performance.now();
Logger.info(`Operation completed in ${endTime - startTime}ms`);
```

---

**改訂履歴**

| バージョン | 日付 | 変更内容 |
|----------|------|----------|
| 1.0 | 2025-08-21 | 初版作成（実装手順、コーディング規約、運用ガイドを統合） |
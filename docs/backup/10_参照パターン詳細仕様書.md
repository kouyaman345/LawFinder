# 参照パターン詳細仕様書

**作成日**: 2025年8月3日  
**バージョン**: 1.0  
**プロジェクト名**: LawFinder

## 1. 概要

本ドキュメントは、LawFinderシステムにおける法令間・条文間の参照パターンの詳細な分類、検出方法、および実装仕様を定義する。日本の法令文書に特有の参照表現を網羅的に体系化し、AI支援による高精度な参照関係抽出を実現する。

### 1.1 目的

1. **体系的分類**: 法令参照パターンの階層的・網羅的分類体系の確立
2. **検出精度向上**: パターンマッチングとAI解析の組み合わせによる高精度検出
3. **実装指針**: 開発者向けの明確な実装ガイドライン提供
4. **品質保証**: 参照抽出の品質基準と検証方法の明確化

### 1.2 対象範囲

- 日本の法令（法律、政令、省令、規則）における参照表現
- 条文内参照、条文間参照、法令間参照
- 明示的参照および暗黙的参照

## 2. 参照パターン階層分類体系

### 2.1 第1階層: 基本参照タイプ

#### 2.1.1 構造参照（Structure Reference）
法令の構造要素（条、項、号等）への参照

```
パターン例:
- 第○条
- 前項
- 次号
- 同条第○項
```

#### 2.1.2 動作参照（Action Reference）
法的効果や動作を表す参照

```
パターン例:
- ～を準用する
- ～とみなす
- ～に従う
- ～による
```

#### 2.1.3 条件参照（Conditional Reference）
条件や例外を表す参照

```
パターン例:
- ～を除く
- ～にかかわらず
- ～の限りでない
- ～の場合を除き
```

### 2.2 第2階層: 複合参照パターン

#### 2.2.1 条件付き準用（Conditional Application）
```typescript
interface ConditionalApplication {
  basePattern: "準用";
  conditions: string[];
  exceptions: string[];
  replacements: Map<string, string>;
}

// 例: 「第○条の規定は、○○の場合に限り、「A」を「B」と読み替えて準用する」
```

#### 2.2.2 多段階参照（Multi-level Reference）
```typescript
interface MultiLevelReference {
  referenceChain: ReferenceNode[];
  finalTarget: LegalElement;
}

// 例: 「第○条第○項の規定により準用される第○条の規定」
```

#### 2.2.3 選択的参照（Alternative Reference）
```typescript
interface AlternativeReference {
  primaryReference: Reference;
  alternativeReferences: Reference[];
  selectionCriteria: string;
}

// 例: 「第○条又は第○条の規定により」
```

### 2.3 第3階層: 暗黙的参照パターン

#### 2.3.1 位置参照（Positional Reference）
```
パターン:
- 前条
- 次条
- 前三条
- 以下この条において同じ
```

#### 2.3.2 定義参照（Definition Reference）
```
パターン:
- 以下「○○」という。
- （以下同じ。）
- この法律において
```

#### 2.3.3 包括参照（Comprehensive Reference）
```
パターン:
- この章の規定
- 前章までの規定
- この法律の規定
```

## 3. パターン検出実装仕様

### 3.1 正規表現パターン定義

```javascript
const REFERENCE_PATTERNS = {
  // 構造参照パターン
  structure: {
    article: {
      pattern: /第([一二三四五六七八九十百千]+|[\d０-９]+)条/g,
      type: 'ARTICLE',
      captureGroups: ['articleNumber']
    },
    paragraph: {
      pattern: /(第([一二三四五六七八九十百千]+|[\d０-９]+)項|前項|次項|同項)/g,
      type: 'PARAGRAPH',
      captureGroups: ['fullMatch', 'paragraphNumber']
    },
    item: {
      pattern: /(第([一二三四五六七八九十百千]+|[\d０-９]+)号|前号|次号|各号)/g,
      type: 'ITEM',
      captureGroups: ['fullMatch', 'itemNumber']
    }
  },
  
  // 動作参照パターン
  action: {
    apply: {
      pattern: /((.*?)の規定)?(?:について|を)?準用(?:する|し)/g,
      type: 'APPLY',
      captureGroups: ['fullMatch', 'targetProvision']
    },
    deem: {
      pattern: /((.*?)(?:と)?みなす|看做す)/g,
      type: 'DEEM',
      captureGroups: ['fullMatch', 'deemedContent']
    },
    replace: {
      pattern: /「([^」]+)」を「([^」]+)」と読み替え(?:る|て|るものとする)/g,
      type: 'REPLACE',
      captureGroups: ['fullMatch', 'originalText', 'replacementText']
    },
    follow: {
      pattern: /((.*?)に(?:よる|よって|より|従い|従って|基づく|基づいて|基づき))/g,
      type: 'FOLLOW',
      captureGroups: ['fullMatch', 'targetProvision']
    }
  },
  
  // 条件参照パターン
  conditional: {
    except: {
      pattern: /((.*?)(?:を|場合を)?除(?:く|き|いて))/g,
      type: 'EXCEPT',
      captureGroups: ['fullMatch', 'exception']
    },
    regardless: {
      pattern: /((.*?)(?:に)?かかわらず|を問わず)/g,
      type: 'REGARDLESS',
      captureGroups: ['fullMatch', 'disregardedCondition']
    },
    limit: {
      pattern: /((?:この|その)?限り(?:で)?(?:ない)?)/g,
      type: 'LIMIT',
      captureGroups: ['fullMatch']
    }
  },
  
  // 複合パターン
  compound: {
    conditionalApply: {
      pattern: /((.*?)の場合に(?:限り|おいて)、(?:「([^」]+)」を「([^」]+)」と読み替えて)?(.*)準用する)/g,
      type: 'CONDITIONAL_APPLY',
      captureGroups: ['fullMatch', 'condition', 'originalText', 'replacementText', 'targetProvision']
    },
    multiReference: {
      pattern: /((.*?)の規定により準用される(.*?)の規定)/g,
      type: 'MULTI_REFERENCE',
      captureGroups: ['fullMatch', 'firstProvision', 'secondProvision']
    }
  }
};
```

### 3.2 パターンマッチングエンジン

```typescript
class ReferencePatternMatcher {
  private patterns: Map<string, PatternDefinition>;
  private contextAnalyzer: ContextAnalyzer;
  
  constructor() {
    this.patterns = this.initializePatterns();
    this.contextAnalyzer = new ContextAnalyzer();
  }
  
  async extractReferences(text: string, context: LegalContext): Promise<ExtractedReference[]> {
    const references: ExtractedReference[] = [];
    
    // 1. 第1段階: 基本パターンマッチング
    for (const [categoryName, category] of Object.entries(REFERENCE_PATTERNS)) {
      for (const [patternName, pattern] of Object.entries(category)) {
        const matches = this.matchPattern(text, pattern);
        references.push(...matches);
      }
    }
    
    // 2. 第2段階: 文脈分析による参照の結合
    const combinedReferences = this.combineReferences(references, text);
    
    // 3. 第3段階: 参照の曖昧性解消
    const disambiguatedReferences = await this.disambiguateReferences(
      combinedReferences, 
      context
    );
    
    // 4. 第4段階: 参照先の推定
    const resolvedReferences = await this.resolveTargets(
      disambiguatedReferences,
      context
    );
    
    return resolvedReferences;
  }
  
  private matchPattern(text: string, pattern: PatternDefinition): MatchedReference[] {
    const matches: MatchedReference[] = [];
    let match;
    
    while ((match = pattern.pattern.exec(text)) !== null) {
      const capturedGroups: { [key: string]: string } = {};
      
      pattern.captureGroups.forEach((groupName, index) => {
        capturedGroups[groupName] = match[index + 1] || '';
      });
      
      matches.push({
        type: pattern.type,
        matchedText: match[0],
        position: {
          start: match.index,
          end: match.index + match[0].length
        },
        capturedGroups,
        confidence: 1.0, // 正規表現マッチは高信頼度
        context: this.extractContext(text, match.index)
      });
    }
    
    return matches;
  }
  
  private extractContext(text: string, position: number, windowSize: number = 100): string {
    const start = Math.max(0, position - windowSize);
    const end = Math.min(text.length, position + windowSize);
    return text.slice(start, end);
  }
}
```

### 3.3 AI支援による参照解決

```typescript
class AIReferenceResolver {
  private llm: LocalLLM;
  private referenceKnowledgeBase: ReferenceKnowledgeBase;
  
  constructor() {
    this.llm = new LocalLLM({
      model: 'llama3-elyza-jp-8b',
      temperature: 0.1,
      maxTokens: 1000
    });
    this.referenceKnowledgeBase = new ReferenceKnowledgeBase();
  }
  
  async resolveReference(reference: MatchedReference, context: LegalContext): Promise<ResolvedReference> {
    // 1. 知識ベースからの候補取得
    const candidates = await this.referenceKnowledgeBase.getCandidates(reference, context);
    
    // 2. プロンプト生成
    const prompt = this.generateResolutionPrompt(reference, candidates, context);
    
    // 3. LLM推論
    const response = await this.llm.generate(prompt);
    
    // 4. 結果解析と検証
    const parsedResult = this.parseAIResponse(response);
    const validatedResult = await this.validateResult(parsedResult, context);
    
    return {
      ...reference,
      targetLawId: validatedResult.targetLawId,
      targetArticleId: validatedResult.targetArticleId,
      targetElementPath: validatedResult.targetElementPath,
      confidence: this.calculateConfidence(reference, validatedResult),
      aiAnalysis: {
        model: 'llama3-elyza-jp-8b',
        reasoning: validatedResult.reasoning,
        alternativeCandidates: validatedResult.alternatives,
        analyzedAt: new Date()
      }
    };
  }
  
  private generateResolutionPrompt(
    reference: MatchedReference, 
    candidates: Candidate[], 
    context: LegalContext
  ): string {
    return `
# 法令参照解決タスク

## 現在の文脈
- 法令: ${context.currentLaw.title} (${context.currentLaw.id})
- 条文: 第${context.currentArticle.number}条
- 位置: ${context.currentParagraph ? `第${context.currentParagraph.number}項` : ''}

## 参照テキスト
"${reference.matchedText}"

## 前後の文脈
${reference.context}

## 参照候補
${candidates.map((c, i) => `
${i + 1}. ${c.lawTitle} 第${c.articleNumber}条
   - 法令ID: ${c.lawId}
   - 関連度スコア: ${c.relevanceScore}
   - 内容要約: ${c.summary}
`).join('\n')}

## タスク
上記の参照テキストが指している具体的な法令・条文を特定してください。

## 出力形式（JSON）
{
  "targetLawId": "特定した法令ID",
  "targetLawTitle": "特定した法令名",
  "targetArticleNumber": 特定した条番号,
  "targetParagraphNumber": 項番号（該当する場合）,
  "targetItemNumber": 号番号（該当する場合）,
  "confidence": 0.0-1.0の信頼度,
  "reasoning": "判断の根拠（100文字以内）",
  "alternatives": [
    {
      "lawId": "代替候補の法令ID",
      "articleNumber": 代替候補の条番号,
      "likelihood": 0.0-1.0の可能性
    }
  ]
}
`;
  }
}
```

## 4. 参照パターン優先度と競合解決

### 4.1 パターン優先度

```typescript
const PATTERN_PRIORITY = {
  // 明示的 > 暗黙的
  explicit: {
    fullReference: 1000,      // "民法第○条"
    partialReference: 900,    // "第○条"
    structuralReference: 800  // "前項"
  },
  
  // 具体的 > 抽象的
  specificity: {
    withNumber: 100,     // "第123条"
    withRelative: 90,    // "前条"
    withDemonstrative: 80 // "同条"
  },
  
  // 近接度による調整
  proximity: {
    sameArticle: 10,
    sameParagraph: 20,
    sameItem: 30
  }
};

class ReferenceConflictResolver {
  resolve(references: ExtractedReference[]): ExtractedReference[] {
    // 重複する参照を検出
    const overlapping = this.findOverlappingReferences(references);
    
    // 優先度に基づいて解決
    return overlapping.map(group => {
      return group.sort((a, b) => {
        const priorityA = this.calculatePriority(a);
        const priorityB = this.calculatePriority(b);
        return priorityB - priorityA;
      })[0];
    });
  }
}
```

### 4.2 エッジケース処理

```typescript
const EDGE_CASES = {
  // 循環参照の検出
  circularReference: {
    pattern: /第(\d+)条.*準用.*第\1条/,
    handler: (match) => {
      return {
        type: 'CIRCULAR_REFERENCE',
        requiresManualReview: true
      };
    }
  },
  
  // 存在しない条文への参照
  invalidReference: {
    validator: async (reference, lawDatabase) => {
      const exists = await lawDatabase.articleExists(
        reference.targetLawId,
        reference.targetArticleNumber
      );
      return exists;
    }
  },
  
  // 将来法への参照
  futureReference: {
    pattern: /（.*年.*月.*日から施行）/,
    handler: (match, currentDate) => {
      const enforcementDate = parseDate(match[1]);
      return {
        isValid: enforcementDate <= currentDate,
        enforcementDate
      };
    }
  }
};
```

## 5. 品質保証とテスト

### 5.1 参照パターンテストケース

```yaml
test_cases:
  - category: 基本構造参照
    cases:
      - input: "第123条の規定により"
        expected:
          type: ARTICLE
          articleNumber: 123
          confidence: 1.0
      
      - input: "前項の規定にかかわらず"
        expected:
          type: PARAGRAPH
          relative: PREVIOUS
          confidence: 1.0
  
  - category: 複合参照
    cases:
      - input: "第10条の規定は、第20条の場合に限り、「届出」を「申請」と読み替えて準用する"
        expected:
          type: CONDITIONAL_APPLY
          sourceArticle: 10
          targetArticle: 20
          replacements:
            - original: "届出"
              replacement: "申請"
          confidence: 0.95
  
  - category: 暗黙的参照
    cases:
      - input: "この章の規定は、前章の規定を準用する"
        expected:
          type: CHAPTER_REFERENCE
          sourceChapter: CURRENT
          targetChapter: PREVIOUS
          action: APPLY
          confidence: 0.9
```

### 5.2 品質メトリクス

```typescript
interface QualityMetrics {
  // 精度指標
  precision: number;         // 正しく抽出された参照 / 全抽出参照
  recall: number;           // 正しく抽出された参照 / 実際の参照
  f1Score: number;          // 2 * (precision * recall) / (precision + recall)
  
  // パフォーマンス指標
  averageProcessingTime: number;  // ミリ秒/条文
  aiUsageRate: number;           // AI解析が必要だった割合
  
  // エラー分析
  errorTypes: {
    missingReference: number;      // 抽出漏れ
    incorrectTarget: number;       // 誤った参照先
    lowConfidence: number;         // 低信頼度（< 0.7）
    circularReference: number;     // 循環参照
  };
}
```

## 6. 実装ガイドライン

### 6.1 開発フロー

1. **パターン定義フェーズ**
   - 正規表現パターンの実装
   - テストケースの作成
   - パターン優先度の設定

2. **統合フェーズ**
   - パターンマッチャーの実装
   - コンテキスト分析器の実装
   - AI解決器の統合

3. **検証フェーズ**
   - 単体テストの実行
   - 実データでの検証
   - パフォーマンス測定

### 6.2 コーディング標準

```typescript
// 参照抽出クラスの基本構造
export class ReferenceExtractor implements IReferenceExtractor {
  private readonly patternMatcher: PatternMatcher;
  private readonly contextAnalyzer: ContextAnalyzer;
  private readonly aiResolver: AIReferenceResolver;
  private readonly logger: Logger;
  
  constructor(config: ReferenceExtractorConfig) {
    this.patternMatcher = new PatternMatcher(config.patterns);
    this.contextAnalyzer = new ContextAnalyzer(config.contextWindow);
    this.aiResolver = new AIReferenceResolver(config.aiConfig);
    this.logger = new Logger('ReferenceExtractor');
  }
  
  async extract(text: string, context: LegalContext): Promise<Reference[]> {
    this.logger.info('Starting reference extraction', { 
      textLength: text.length,
      context: context.toString()
    });
    
    try {
      // 実装...
    } catch (error) {
      this.logger.error('Reference extraction failed', error);
      throw new ReferenceExtractionError(error);
    }
  }
}
```

## 7. 今後の拡張計画

### 7.1 短期計画（Phase 1）
- 基本パターンの実装完了
- 単体テストの整備
- 性能ベンチマークの確立

### 7.2 中期計画（Phase 1.5）
- AI解析の精度向上
- 新規パターンの追加
- リアルタイム解析の実装

### 7.3 長期計画（Phase 2）
- 機械学習モデルの導入
- 多言語対応（英語法令）
- 国際条約への対応

## 8. 改訂履歴

| バージョン | 日付 | 変更内容 |
|----------|------|----------|
| 1.0 | 2025-08-03 | 初版作成 |
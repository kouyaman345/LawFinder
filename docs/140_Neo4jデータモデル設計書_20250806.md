# Neo4jデータモデル設計書

**作成日**: 2025年8月6日  
**プロジェクト**: LawFinder Phase 2

## 1. 概要

LawFinderのNeo4jデータモデルは、法令間の複雑な参照関係を効率的に表現し、改正影響分析（ハネ改正検出）を高速に実行できるよう設計されています。

## 2. ノード（Nodes）

### 2.1 Law（法令）
```cypher
(:Law {
  id: String,           // 法令ID (例: "129AC0000000089")
  title: String,        // 法令名 (例: "民法")
  lawNumber: String,    // 法令番号 (例: "明治二十九年法律第八十九号")
  lawType: String,      // 法令種別 (例: "法律", "政令", "省令")
  effectiveDate: Date,  // 施行日
  promulgationDate: Date, // 公布日
  lastUpdated: DateTime,  // 最終更新日時
  status: String        // 状態 ("現行", "廃止", "改正予定")
})
```

### 2.2 Article（条）
```cypher
(:Article {
  id: String,           // 条文ID (例: "129AC0000000089_709")
  lawId: String,        // 所属法令ID
  number: String,       // 条番号 (例: "七百九", "三の二")
  title: String,        // 条見出し（ある場合）
  content: String,      // 条文本文（第1項のテキスト）
  
  // 階層情報
  part: String,         // 編 (例: "第二編")
  chapter: String,      // 章 (例: "第一章")
  section: String,      // 節 (例: "第三節")
  subsection: String,   // 款
  division: String,     // 目
  
  // メタ情報
  effectiveDate: Date,  // この条文の施行日
  isDeleted: Boolean    // 削除条文フラグ
})
```

### 2.3 Paragraph（項）
```cypher
(:Paragraph {
  id: String,           // 項ID
  articleId: String,    // 所属条文ID
  number: Integer,      // 項番号 (1, 2, 3...)
  content: String,      // 項の内容
  sentenceCount: Integer // 文の数
})
```

### 2.4 Item（号）
```cypher
(:Item {
  id: String,           // 号ID
  paragraphId: String,  // 所属項ID
  number: String,       // 号番号 (例: "一", "二の三")
  content: String,      // 号の内容
  type: String          // 種別 ("号", "イロハ", "いろは")
})
```

### 2.5 Amendment（改正）
```cypher
(:Amendment {
  id: String,           // 改正ID
  lawId: String,        // 改正法令ID
  targetLawId: String,  // 改正対象法令ID
  effectiveDate: Date,  // 改正施行日
  description: String,  // 改正内容の説明
  status: String        // 状態 ("予定", "施行済")
})
```

## 3. リレーションシップ（Relationships）

### 3.1 構造的関係
```cypher
// 法令が条文を持つ
(:Law)-[:HAS_ARTICLE]->(:Article)

// 条文が項を持つ
(:Article)-[:HAS_PARAGRAPH]->(:Paragraph)

// 項が号を持つ
(:Paragraph)-[:HAS_ITEM]->(:Item)

// 条文の順序関係
(:Article)-[:NEXT_ARTICLE]->(:Article)
(:Article)-[:PREV_ARTICLE]->(:Article)
```

### 3.2 参照関係
```cypher
// 内部参照（同一法令内）
(:Article)-[:REFERS_TO {
  type: "internal",
  text: String,          // 参照テキスト
  confidence: Float,     // 信頼度 (0.0-1.0)
  context: String        // 文脈
}]->(:Article)

// 外部参照（他法令）
(:Article)-[:REFERS_TO_EXTERNAL {
  type: "external",
  lawName: String,       // 参照先法令名
  articleNumber: String, // 参照先条番号
  text: String,
  confidence: Float
}]->(:Law)

// 相対参照
(:Article)-[:RELATIVE_REF {
  direction: String,     // "previous", "next", "same"
  distance: Integer,     // 距離（前二条なら2）
  type: String,          // "条", "項", "号"
  text: String
}]->(:Article)

// 準用関係
(:Article)-[:APPLIES {
  type: "準用",
  scope: String,         // 準用範囲
  modifications: String, // 読替規定
  text: String
}]->(:Article)

// 構造参照（章・編など）
(:Article)-[:REFERS_TO_STRUCTURE {
  structureType: String, // "章", "編", "節"
  text: String
}]->(:Article)
```

### 3.3 改正関係
```cypher
// 改正による変更
(:Amendment)-[:AMENDS]->(:Article)

// 改正の影響
(:Article)-[:AFFECTED_BY]->(:Amendment)

// 条文の版管理
(:Article)-[:REPLACED_BY {
  effectiveDate: Date,
  reason: String
}]->(:Article)
```

## 4. インデックスと制約

### 4.1 ユニーク制約
```cypher
CREATE CONSTRAINT law_id_unique FOR (l:Law) REQUIRE l.id IS UNIQUE;
CREATE CONSTRAINT article_id_unique FOR (a:Article) REQUIRE a.id IS UNIQUE;
CREATE CONSTRAINT paragraph_id_unique FOR (p:Paragraph) REQUIRE p.id IS UNIQUE;
CREATE CONSTRAINT item_id_unique FOR (i:Item) REQUIRE i.id IS UNIQUE;
```

### 4.2 インデックス
```cypher
CREATE INDEX law_title FOR (l:Law) ON (l.title);
CREATE INDEX law_status FOR (l:Law) ON (l.status);
CREATE INDEX article_law_number FOR (a:Article) ON (a.lawId, a.number);
CREATE INDEX article_chapter FOR (a:Article) ON (a.chapter);
CREATE INDEX amendment_effective FOR (am:Amendment) ON (am.effectiveDate);
```

## 5. クエリ例

### 5.1 ハネ改正の検出
```cypher
// 民法709条を改正した場合の影響範囲（5段階まで）
MATCH path = (source:Article {lawId: "129AC0000000089", number: "七百九"})
  <-[:REFERS_TO|REFERS_TO_EXTERNAL|APPLIES|RELATIVE_REF*1..5]-(affected:Article)
WITH affected, path, length(path) as distance
RETURN DISTINCT affected.lawId, affected.number, min(distance) as minDistance
ORDER BY minDistance, affected.lawId, affected.number
```

### 5.2 準用関係の連鎖
```cypher
// 準用関係を辿る
MATCH path = (a:Article)-[:APPLIES*]-(b:Article)
WHERE a.lawId = "417AC0000000086" AND a.number = "一〇〇"
RETURN path
```

### 5.3 章内の相互参照
```cypher
// 特定の章内での参照関係
MATCH (a:Article {chapter: "第二章"})-[r:REFERS_TO]->(b:Article {chapter: "第二章"})
WHERE a.lawId = "417AC0000000086"
RETURN a, r, b
```

### 5.4 改正履歴の追跡
```cypher
// 条文の改正履歴
MATCH (a:Article {id: "129AC0000000089_709"})-[:REPLACED_BY*]->(latest:Article)
WHERE NOT (latest)-[:REPLACED_BY]->()
RETURN a, latest
```

## 6. パフォーマンス考慮事項

1. **バッチ処理**: 大量データのインポート時は`UNWIND`を使用
2. **トランザクション分割**: 10,000件ごとにコミット
3. **メモリ設定**: heap.initial_size=512m, heap.max_size=2G
4. **プロファイリング**: `PROFILE`を使用してクエリ最適化

## 7. 将来の拡張

1. **全文検索統合**: Elasticsearchとの連携
2. **時系列分析**: 改正頻度の分析
3. **グラフアルゴリズム**: 中心性分析、コミュニティ検出
4. **機械学習**: 参照パターンの学習と予測